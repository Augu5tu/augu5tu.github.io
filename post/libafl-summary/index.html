<!DOCTYPE html>
<html>
<head>
<link rel="shortcut icon" href="https://augu5tu.github.io/favicon.ico" type="image/x-icon" /><meta name="viewport"content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="apple-mobile-web-app-capable"content="yes"/><meta name="apple-mobile-web-app-status-bar-style"content="black"/><meta name="format-detection"content="telephone=no"/><meta name="renderer"content="webkit"><meta name="description"content="飞光之下，对结构与失序的片刻凝视，录于此间：对若干封闭系统的交互逻辑作审慎考察；观测特定输入变异对系统状态产生的效应；以及某些非预期行为的溯源与校正。&lt;br&gt;
另，偶于叙事构造中暂留。&lt;br&gt;"><meta charset="UTF-8"><title>LibAFL 框架总结 | Augu5tu-飞光</title>
<link href="https://augu5tu.github.io/styles/main.css" type="text/css" rel="stylesheet" /><link href="https://at.alicdn.com/t/font_1621793_zatzzgvf30g.css" type="text/css" rel="stylesheet" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css"><script async src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.min.js"></script><script src="https://augu5tu.github.io/media/js/magnify.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
<script type="text/javascript">function btn_toggle(){document.getElementById("hn").classList.contains("no-js")?document.getElementById("hn").classList.remove("no-js"):document.getElementById("hn").classList.add("no-js")}</script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-DLNENTJ4LP"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag() {
		dataLayer.push(arguments);
	}
	gtag('js', new Date());
	gtag('config', 'G-DLNENTJ4LP');
</script>

<link rel="canonical" href="https://augu5tu.github.io/post/libafl-summary/" />
</head>
<body>
<div class="progress"></div><style>.progress{background:linear-gradient(to right,#87ceeb var(--scroll),transparent 0);background-repeat:no-repeat;position:fixed;width:100%;height:4px;z-index:1}</style><div class="darkmode-background"></div><div class="darkmode-layer"></div>
<noscript><p class="warn" >本页面需要浏览器支持（启用）JavaScript</p></noscript><div class="header"><div class="logo_title"><div class="title animated fadeInDown"><a href="https://augu5tu.github.io"><img alt="logo" style="display:inline-block;" src="https://augu5tu.github.io/images/avatar.png"/></a><h1 title="Augu5tu-飞光" class="weaklink"><a  href="/">Augu5tu-飞光</a></h1>

<div class="navbar weaklink">
<div class="normal_nav">
<div class="bitcron_nav_container"><div class="bitcron_nav"><div class="bitcron_nav"><div style="display:flex;justify-content:center;"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li></ul></nav>
<div style="float:right;margin-top:1em"><form id="gridea-search-form" data-update="1578893743252" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="Search..."></form></div><div style="margin-left:0.5em;margin-top:1.2em"><input id="switch_default" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
<div class="clear clear_nav_inline_end"></div></div></div><div class="clear clear_nav_end"></div></div></div><div class="hamberger" href="javascript:void(0)" onclick="btn_toggle();"><i class="iconfont icon-category"></i></div></div></div></div>
<div id="hn" class="no-js hidden_nav animated fadeInDown"><div class="bitcron_nav_container"><div class="bitcron_nav"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li></ul><div class="clear clear_nav_inline_end"></div></nav></div><div class="clear clear_nav_end"></div></div>
<div style="display:flex;justify-content:center;inline-block;text-align:center;margin-top:7%"><div><form id="gridea-search-form" data-update="1748232441122" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q"  placeholder="Search..." /></form></div><div style="margin-left:0.5em"><input id="switch_default_h" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
</div></div>
<script>function enableDarkmode(){document.body.classList.add("darkmode"),document.getElementById("switch_default").checked=1,document.getElementById("switch_default_h").checked=1}function removeDarkmode(){document.body.classList.remove("darkmode"),document.getElementById("switch_default").checked=0,document.getElementById("switch_default_h").checked=0}function getCookie(a){var b,c=new RegExp("(^| )"+a+"=([^;]*)(;|$)");return(b=document.cookie.match(c))?unescape(b[2]):null}cookie=getCookie("darkmode"),"enable"==cookie&&enableDarkmode(),window.matchMedia("(prefers-color-scheme: dark)").matches&&"disable"!==cookie&&(enableDarkmode(),document.cookie="darkmode=enable; path=/");var mobileBtn=function(){1==document.getElementById("switch_default").checked?(enableDarkmode(),document.cookie="darkmode=enable; path=/"):(removeDarkmode(),document.cookie="darkmode=disable; path=/")};</script>

<div class="main"><div class="main-inner"><div class="content">
<article class="post">
<h2 class="post_title sm_margin"><a>LibAFL 框架总结</a></h2>
<script>function lan(){if(document.getElementById("lan").innerText=="繁"){var s=document.getElementById("tongwenlet_cn");if(s!=null){document.body.removeChild(s)}var s=document.createElement("script");s.language="javascript";s.type="text/javascript";s.src="https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_tw.js";s.id="tongwenlet_cn";document.body.appendChild(s);document.getElementById("lan").innerHTML="简"}else{if(document.getElementById("lan").innerText=="簡"){var s=document.getElementById("tongwenlet_cn");if(s!=null){document.body.removeChild(s)}var s=document.createElement("script");s.language="javascript";s.type="text/javascript";s.src="https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_cn.js";s.id="tongwenlet_cn";document.body.appendChild(s);document.getElementById("lan").innerHTML="繁"}}};</script>
<section class="post_details"><i class="iconfont icon-calendar"></i><span style="margin-right:15px"> 2025-05-22</span><i class="iconfont icon-browse"></i><span style="margin-right:15px"> <span id="busuanzi_value_page_pv"></span> Views</span><i class="iconfont icon-category"></i><span class="weaklink" style="margin-right:15px">	<a href="https://augu5tu.github.io/tag/TIiX259X_9/" class="tag">模糊测试</a> | 	<a href="https://augu5tu.github.io/tag/ikU9-dGND5u/" class="tag">fuzz</a> | 	<a href="https://augu5tu.github.io/tag/pYJe21pU8F/" class="tag">技术</a></span><i class="iconfont icon-caret-down"></i><span style="margin-right:15px">13228字</span><i class="iconfont icon-naozhong"></i><span style="margin-right:15px">48 min read</span><a id="lan" href="javascript:void(0);"onclick="lan();"title="调整简繁体" style="margin-right:15px;">繁</a>
</section>

<img class="featureImg" alt="featureimg" src="https://raw.githubusercontent.com/AFLplusplus/Website/main/static/libafl_logo.svg" referrerpolicy="no-referrer">

<div style="display:flex">
<div class="md_block" id="md_block">
<div class="round-shape-one"></div>
<p>LibAFL的相关教程还是太少了，之前学习的时候主要是依靠epi的<a href="https://epi052.gitlab.io/notes-to-self/blog/2021-11-01-fuzzing-101-with-libafl/">系列博客</a>，但问题其实挺大，最主要的是版本比较老了，当时他用的是0.10.1的，而且就了解整个LibAFL来说，他的博客其实是目标驱动的，我认为选择的时候并没有介绍选择某个组件的理由（为什么不选其他的，我们是否还有别的选择之类），这当然不是作者的问题，但鉴于LibAFL并没有一个学习难度足够平滑的教程，我们唯一的选择大概只有看它的API文档，恰巧rust自动生成的API文档其实足够翔实，我来总结一下，方便自己对LibAFL的大部分组件有一个初步的笼统的了解，另附LibAFL简单介绍，用于应付面试</p>
<h3 id="tokens">tokens</h3>
<p>Tokens 是一些对目标程序有特殊意义的字节序列或字符串，比如文件格式的魔术数字、协议的关键词等。在 LibAFL 中，我们可以通过提供一个 token 文件，将这些 tokens 加载到 Fuzzing 状态的元数据中。然后，像 <code>StdMOptMutator</code> 配合 <code>tokens_mutations</code> 这样的变异器，就可以在变异输入时使用这些 tokens，例如将它们插入或替换到现有输入中。这样做的好处是，Fuzzer 可以更快地生成能够通过程序初步解析、触及更深代码逻辑的输入，从而提高发现漏洞的效率，特别是对于那些输入结构要求比较严格的目标程序。</p>
<h3 id="duration">Duration</h3>
<p>rust标准库中用来表示时间跨度的一个结构体</p>
<h3 id="module">module</h3>
<p>对于libafl_qemu中的module，准确描述为：</p>
<ul>
<li><strong>扩展 QEMU 功能的插件或钩子 (Hooks)</strong>：它们允许你在 QEMU 模拟执行目标程序的各个关键阶段注入自定义的 Rust 代码。</li>
<li><strong>信息收集与交互</strong>：它们的主要目的是从 QEMU 的执行流中收集对 Fuzzing 有用的信息（如边覆盖率、比较指令的操作数），或者与 Fuzzer 的其他组件（如 Observer）进行交互以传递这些信息。</li>
<li><strong>行为修改 (有限)</strong>：在某些情况下，它们也可以轻微地修改 QEMU 的行为或目标程序的状态，但主要不是用来“传递命令”给 QEMU 以执行任意操作。QEMU 的主要行为还是由 <code>Emulator</code> 对象及其方法（如 <code>run</code>, <code>set_breakpoint</code>, <code>write_reg</code> 等）来控制。</li>
</ul>
<p><strong><code>StdEdgeCoverageModule</code> 如何工作（回顾）：</strong></p>
<ul>
<li>它在 QEMU 翻译或执行基本块时，设置钩子。</li>
<li>当发生基本块跳转（边执行）时，它内部的逻辑（或其关联的 helper）会计算边的哈希，并更新由 <code>edges_observer</code> 指向的共享内存区域。</li>
<li>它<strong>不是给 QEMU 发命令</strong>说“记录这条边”，而是<strong>利用 QEMU 提供的钩子点</strong>，在适当的时候自己执行记录操作。</li>
</ul>
<p><strong><code>CmpLogModule</code> 对于 Fuzzer 的具体作用</strong>：</p>
<ol>
<li>提供变异提示 (Mutation Hints)：
<ul>
<li>收集到的比较操作数（尤其是那些其中一个操作数来源于 Fuzzer 输入，另一个是程序内部的常量或计算值）是非常有价值的“字典”或“token”。</li>
<li>例如，如果 <code>CmpLogModule</code> 记录到程序将输入的某个部分与字符串 &quot;USER_ADMIN&quot; 进行了比较，那么 Fuzzer 在后续的变异中就可以尝试将输入的相应部分修改为 &quot;USER_ADMIN&quot;。</li>
</ul>
</li>
<li>驱动 Input-to-State (I2S) 变异器：
<ul>
<li>像 <code>I2SRandReplace</code> 这样的变异器，其核心思想就是利用这些从运行时状态（如 CmpLog）中收集到的值。</li>
<li><code>CmpLogObserver</code> 会读取由 <code>CmpLogModule</code> 收集的数据，并通过 <code>State</code> 的元数据 (Metadata) 系统提供给 <code>I2SRandReplace</code>。</li>
<li><code>I2SRandReplace</code> 就可以使用这些记录的比较值来智能地替换输入中的字节，目标是直接满足之前观察到的比较条件，从而引导程序进入新的分支。这通常比纯粹的随机变异（如 bit flipping）更有效率地发现新路径。</li>
</ul>
</li>
<li><strong>Redqueen 技术的基础</strong>：CmpLog 是 Redqueen（或称 Input-to-State an Input-to-State Transformation）这类 Fuzzing 技术的基础。Redqueen 尝试自动解决程序中的比较检查，将被污染的（来自输入的）操作数替换为目标值，从而“净化”输入，使其通过检查。</li>
</ol>
<h2 id="具体模块">具体模块</h2>
<h3 id="observer">observer</h3>
<h4 id="cmp">cmp</h4>
<p><code>CmpLogObserver</code> 的核心作用是在 Fuzzing 过程中<strong>捕获和记录目标程序执行比较指令（如 <code>if (a == b)</code>) 时的操作数值</strong>。这种技术通常被称为 &quot;RedQueen&quot;、&quot;LAF-intel&quot; 或 &quot;CompareCoverage&quot;。</p>
<p><strong>为什么重要</strong>: 很多程序包含大量的条件检查，Fuzzer 如果只是随机变异输入，很难猜到满足这些检查的确切值，从而无法进入新的代码路径。<code>CmpLogObserver</code> 通过记录实际参与比较的值，为 Fuzzer 提供了“线索”，帮助它：</p>
<ul>
<li><strong>绕过检查</strong>: 当 Fuzzer 知道输入 <code>0x41</code> 与常量 <code>0x78</code> 进行了比较但未通过时，它可以尝试将输入修改为 <code>0x78</code>。</li>
<li><strong>探索更深路径</strong>: 通过满足更多的条件检查，Fuzzer 可以触及之前未曾覆盖到的代码。</li>
<li><strong>提高效率</strong>: 相比盲目猜测，这是一种更智能、更具指导性的变异方式。</li>
</ul>
<p><code>libafl::observers::cmp</code> 提供了处理比较日志的<strong>通用组件和接口</strong>。<code>StdCmpObserver</code> 是其中的一个通用实现，依赖于 <code>CmpMap</code> 来获取数据。</p>
<p><code>libafl_targets::cmps::observers::cmplog::CmpLogObserver</code></p>
<p>是一个 <code>CmpObserver</code> 的具体实现</p>
<p><strong>它的“特定性”在于，它被设计为直接与 <code>libafl_qemu</code> 的 <code>CmpLogModule</code> 紧密配合。</strong> <code>CmpLogModule</code> 是 QEMU 特有的，它在 QEMU 执行目标程序时，会将捕获到的比较指令操作数写入一块特定格式的共享内存区域。</p>
<h4 id="concolic">concolic</h4>
<p>“Concolic”（符号化执行与具体执行相结合）是一种更高级的模糊测试技术。简单来说，它分几步走：</p>
<ol>
<li>程序会用一个<strong>具体的</strong>输入值运行（就像普通的模糊测试）。</li>
<li>在运行时，它会<strong>符号化地</strong>追踪输入是如何影响程序执行路径的，并记录下程序走到当前路径所必须满足的条件（称为路径约束）。</li>
<li>然后，它会用一个<strong>约束求解器</strong>来分析这些条件，并尝试找到能够满足一组略微不同条件的新输入值，目标是引导程序在下一次执行时走上一条<strong>新的路径</strong>。</li>
</ol>
<p>这种方法对于绕过那些随机变异很难通过的复杂检查特别有用。</p>
<p>“符号化”就是： <strong>程序在处理输入（或者由输入派生出来的数据）时，不立即使用输入的具体数值，而是用一个代号（符号）来代表它，并且记录下程序对这个代号所做的所有运算和比较，形成了一系列的“数学公式”（符号表达式）。</strong></p>
<p>“路径约束”就是： <strong>一个包含了所有符号化条件（这些条件都依赖于程序的输入）的集合，这个集合精确地描述了程序为了执行到当前这一特定代码路径，其输入必须满足的所有逻辑条件。</strong> 每一条从程序开始到某个点的执行路径，都有其对应的一组路径约束。</p>
<p><strong>约束求解器在 concolic fuzzing 中的核心作用就是：</strong></p>
<p><strong>根据 fuzzer “想要”探索的新路径所对应的逻辑条件（修改后的路径约束），智能地计算出能够实际驱动程序走到那条新路径的具体输入值。</strong></p>
<h4 id="map">map</h4>
<ol>
<li>Map Observer 基础</li>
</ol>
<ul>
<li><strong>核心作用</strong>：观察一块共享内存区域（“地图”），这块地图由被<strong>插桩的目标程序</strong>在执行时更新，用以记录代码执行信息，最常见的是<strong>代码覆盖率</strong>。</li>
<li><strong>AFL风格</strong>：其设计深受AFL影响，覆盖率地图通常记录的是程序执行的“边”（edges）或基本块。</li>
<li>工作流程：
<ol>
<li><strong>插桩</strong>：目标程序被插桩。</li>
<li><strong>标记</strong>：目标执行时，插桩代码根据执行路径修改“地图”中的内容（如对应字节+1）。</li>
<li><strong>观察</strong>：LibAFL中的 <code>MapObserver</code> 在目标执行后读取“地图”状态。</li>
<li><strong>反馈</strong>：将观察到的“地图”信息传递给 <code>Feedback</code> 组件，判断输入是否发现了新的覆盖率或其他“有趣”的行为，从而指导后续的输入选择和变异。</li>
</ol>
</li>
<li><strong><code>MapObserver</code> Trait (接口)</strong>：定义了所有 map observer 的基本行为和契约。</li>
<li><strong><code>StdMapObserver</code> Struct (结构体)</strong>：是 <code>MapObserver</code> 的标准、常用具体实现，用于观察由目标程序更新的地图状态。</li>
</ul>
<hr>
<ol start="2">
<li>“地图”本身与大小问题</li>
</ol>
<ul>
<li><strong>“地图”</strong>：一块内存区域，用作位图或字节数组，其每个条目对应程序中可能发生的“事件”或“特征”（主要是边的覆盖）。</li>
<li><strong>边的映射</strong>：通过哈希算法（如 <code>(当前位置 ^ 上一个位置) % MAP_SIZE</code>）将代码执行的“边”映射到地图中的一个索引。</li>
<li><strong>哈希碰撞</strong>：由于地图大小有限（如AFL的64KB），不同的实际代码边可能会映射到地图的同一个位置，这是可接受的，Fuzzer关注的是地图上是否出现了新的变化。</li>
</ul>
<hr>
<ol start="3">
<li>不同类型的 Map Observer</li>
</ol>
<ul>
<li><strong><code>ConstMapObserver</code> (固定大小地图观察者)</strong>
<ul>
<li><strong>含义</strong>：Fuzzer使用的覆盖率地图的大小在Fuzzer<strong>编译时就已确定并固定不变</strong>（例如，硬编码为64KB）。</li>
<li><strong>&quot;编译时知道大小&quot;</strong>：指Fuzzer开发者在编写Fuzzer时确定了地图数据结构的大小，而非指静态分析出目标程序确切的边数量。</li>
<li><strong>优势</strong>：编译器可能对固定大小的内存操作进行优化，加速 <code>Feedback::is_interesting</code> 的判断。</li>
<li><strong>适用场景</strong>：标准的AFL式Fuzzing，地图大小预先设定。</li>
</ul>
</li>
<li><strong><code>VariableMapObserver</code> (可变大小地图观察者)</strong>
<ul>
<li><strong>含义</strong>：关注地图中<strong>实际被使用的部分的大小</strong>。这个“有效大小”可能小于预分配的总大小，并且可能随执行而变化。</li>
<li><strong>优势</strong>：允许Fuzzer更精细地处理有效数据，可能在分析或同步地图时带来优化（例如，只处理“实际使用的256KB”，而不是整个“1MB”）。</li>
<li><strong>澄清</strong>：它不一定意味着地图内存本身在物理上频繁调整大小，更多的是Fuzzer如何理解和利用地图的动态有效区域。</li>
</ul>
</li>
<li><strong><code>hitcount_map</code> Observer (命中次数地图观察者)</strong>
<ul>
<li><strong>功能</strong>：不仅记录边是否被命中，还近似记录其<strong>命中次数</strong>。</li>
<li><strong>分桶 (Bucketing)</strong>：由于地图条目通常为1字节（0-255），使用分桶策略将不同的命中次数范围映射到有限的字节值上（如1次、2次、3次、4-7次、8-15次等）。</li>
<li><strong>反馈价值</strong>：能提供比简单二进制覆盖更细致的反馈，当输入使边的命中次数进入新的“桶”时，也被视为有趣。</li>
</ul>
</li>
<li><strong><code>owned_map</code> Observer (<code>OwnedMapObserver</code>)</strong>
<ul>
<li><strong>核心区别</strong>：与 <code>StdMapObserver</code>（通常观察外部管理的共享内存）不同，<code>OwnedMapObserver</code> <strong>自己分配并拥有其观察的地图内存</strong>。</li>
<li><strong>用途</strong>：简化某些场景的设置，如进程内Fuzzing，或不使用传统AFL forkserver共享内存机制的场景。它在解释地图内容的逻辑上与 <code>StdMapObserver</code> 类似。</li>
</ul>
</li>
<li><strong><code>multi_map</code> Observer (<code>MultiMapObserver</code>)</strong>
<ul>
<li><strong>功能</strong>：允许<strong>同时观察和合并来自多个不同地图（内存区域）的信息</strong>。</li>
<li><strong>用途</strong>：当插桩产生多种类型的覆盖数据（如边覆盖、CmpLog数据）或来自多个独立组件的地图时，<code>MultiMapObserver</code> 提供一个统一的接口来处理这些数据。它可能是概念上的合并（综合判断）而非物理合并。</li>
</ul>
</li>
<li><strong><code>macros</code> (位于 <code>libafl::observers::map</code> 下的模块)</strong>
<ul>
<li><strong>功能</strong>：主要提供与地图相关的<strong>辅助宏</strong>，供其他Observer或Feedback组件内部使用。</li>
<li>例如 <code>crate::require_index_tracking</code> 和 <code>crate::require_novelties_tracking</code> 暗示了这些宏用于启用或检查与追踪地图索引变化和新颖性相关的功能。</li>
<li>它本身不直接提供一个用户可实例化的 Observer 类型。</li>
</ul>
</li>
</ul>
<hr>
<ol start="4">
<li>核心要点回顾</li>
</ol>
<ul>
<li>Map Observer 是覆盖率引导Fuzzing的基石。</li>
<li>它依赖于目标程序的<strong>插桩</strong>来更新共享的“地图”。</li>
<li>最常见的用途是AFL风格的<strong>边覆盖率</strong>（通常带命中次数）。</li>
<li><code>StdMapObserver</code> 是基础，其他类型如 <code>ConstMapObserver</code>, <code>VariableMapObserver</code>, <code>OwnedMapObserver</code>, <code>HitCountMapObserver</code>, <code>MultiMapObserver</code> 提供了针对不同需求（地图大小管理、数据解释、多源数据、内存所有权）的特化或变种。</li>
</ul>
<h3 id="monitor">monitor</h3>
<p><code>Monitor</code> 的核心职责就是<strong>收集、统计和展示 Fuzzer 的运行状态和各种统计信息</strong>。</p>
<h3 id="events">events</h3>
<p><strong>核心职责</strong>： <code>EventManager</code> 是 LibAFL 中负责<strong>通信和协调</strong>的核心组件。它管理 Fuzzer 实例之间或 Fuzzer 内部组件之间的<strong>事件流</strong>。这些事件可以是新发现的测试用例、代码覆盖信息、统计数据、崩溃报告、日志消息等。</p>
<p><strong>关键理念</strong>：</p>
<ul>
<li><strong>按需拼凑与灵活性</strong>：<code>EventManager</code> 不是一个固定的“积木块”，而是按需选择和组合的“能力”组件。用户根据 Fuzzing 目标和部署环境选择合适的实现。</li>
<li><strong>事件驱动</strong>：Fuzzer 的许多活动和发现都以 <code>Event</code> 的形式进行封装和传递。</li>
<li><strong>模块化与可扩展性</strong>：通过 Traits 和不同的模块化实现，支持从简单的单机日志到复杂的多机器协同 Fuzzing。</li>
</ul>
<hr>
<p><strong>一、 通用组件与概念 (<code>libafl::events</code>)</strong></p>
<ul>
<li><strong><code>Event</code> (枚举)</strong>:
<ul>
<li>事件系统的核心数据结构，定义了所有可传递的事件类型，如：
<ul>
<li>新测试用例 (<code>NewTestcase</code>)</li>
<li>统计数据 (<code>Stats</code>)</li>
<li>目标程序崩溃 (<code>Crash</code>)</li>
<li>自定义用户事件 (<code>CustomBuf</code>)</li>
<li>日志消息 (<code>Log</code>)</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>EventManagerId</code> (结构体)</strong>:
<ul>
<li>为每个 Fuzzer 实例提供唯一ID，在多进程环境中尤为重要。</li>
</ul>
</li>
<li><strong><code>NopEventManager</code> (结构体)</strong>:
<ul>
<li>“空操作”事件管理器，不执行实际事件处理，主要用于测试或不需要事件管理的简单场景。</li>
</ul>
</li>
<li><strong><code>MonitorTypedEventManager</code> (结构体)</strong>:
<ul>
<li>包装器，为其他 <code>EventManager</code> 关联一个 <code>Monitor</code> 类型，以统一API。</li>
</ul>
</li>
<li><strong><code>ShutdownSignalData</code> (结构体) 与 <code>EVENTMGR_SIGHANDLER_STATE</code> (静态变量)</strong>:
<ul>
<li>用于捕获 <code>ctrl-c</code> 信号，实现 Fuzzer 的优雅退出。</li>
</ul>
</li>
<li><strong>核心 Traits (接口)</strong>:
<ul>
<li><code>EventFirer</code>: 定义发送（触发）事件的能力。</li>
<li><code>EventReceiver</code>: 定义处理接收到的事件的能力。</li>
<li><code>EventRestarter</code>: 规范可重启事件管理器的行为（如 <code>on_restart</code>）。</li>
<li><code>HasEventManagerId</code>: 允许查询 <code>EventManager</code> 的唯一ID。</li>
<li><code>ProgressReporter</code>: 定义客户端向 Broker 报告 Fuzzing 进度的能力。</li>
<li><code>SendExiting</code>: 定义 Fuzzer 退出前发送通知的能力。</li>
<li><code>AwaitRestartSafe</code>: 定义安全等待重启的行为。</li>
</ul>
</li>
<li><strong>辅助函数</strong>:
<ul>
<li>提供一些 Trait 方法的默认实现，如 <code>std_maybe_report_progress</code>。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>二、 <code>EventManager</code> 的不同实现模块</strong></p>
<ol>
<li><strong><code>simple</code> (<code>libafl::events::simple</code>)</strong>:
<ul>
<li><strong>特点</strong>: 非常简单的事件管理器，主要支持日志输出，<strong>不支持多进程间的事件通信</strong>。</li>
<li><strong><code>SimpleEventManager</code></strong>: 基础的单线程、仅日志记录的实现。</li>
<li><strong><code>SimpleRestartingEventManager</code></strong>: (你代码中使用的) 在 <code>SimpleEventManager</code> 基础上增加了<strong>子进程重启功能</strong>，增强了单机 Fuzzing 的鲁棒性。它通过 <code>Monitor</code> 输出日志。</li>
</ul>
</li>
<li><strong><code>llmp</code> (<code>libafl::events::llmp</code>)</strong>: Low Level Message Passing
<ul>
<li><strong>特点</strong>: 专为<strong>可扩展的单机多进程 Fuzzing</strong> 设计的高性能、低开销进程间通信 (IPC) 机制。</li>
<li><strong>核心技术</strong>: 主要依赖<strong>共享内存</strong>和<strong>无锁/接近无锁</strong>的数据结构。</li>
<li><strong><code>restarting</code> 子模块</strong>: 提供了可重启的 LLMP 事件管理器，能在子进程崩溃时重启并可能恢复状态。</li>
<li><strong>其他特性</strong>: 支持消息压缩 (<code>COMPRESS_THRESHOLD</code>)，状态持久化配置 (<code>LlmpShouldSaveState</code>)。</li>
<li><strong>与LLVM无关</strong>: LLMP 是 LibAFL 内部的通信机制，与编译器基础设施 LLVM 没有直接关系。</li>
</ul>
</li>
<li><strong><code>tcp</code> (<code>libafl::events::tcp</code>)</strong>:
<ul>
<li><strong>特点</strong>: 用于实现<strong>跨多台机器的分布式 Fuzzing</strong>，使用 <strong>TCP/IP 协议</strong>进行网络通信。</li>
<li>架构: 通常采用 Broker-Client 模型。
<ul>
<li><code>TcpEventBroker</code>: 实现 Broker 角色，监听 TCP 连接，中转事件。</li>
<li><code>TcpEventManager</code>: 客户端事件管理器，通过 TCP 发送事件给 Broker。</li>
</ul>
</li>
<li><strong><code>TcpRestartingEventManager</code></strong>: 支持在网络环境中重启 Fuzzer 实例并恢复状态。</li>
</ul>
</li>
<li><strong><code>launcher</code> (<code>libafl::events::launcher</code>)</strong>:
<ul>
<li><strong>核心作用</strong>: <strong>并行启动和管理多个 Fuzzer 实例</strong>，简化在多核 CPU 上的并行 Fuzzing 设置。</li>
<li>功能:
<ul>
<li>自动管理 Broker 启动。</li>
<li>隐藏/显示子进程输出。</li>
<li>支持通过 TCP 连接多节点/多机器。</li>
<li>在 Unix 系统上可选择使用 <code>fork</code> 或重新执行命令的方式创建子进程。</li>
</ul>
</li>
<li><strong><code>CentralizedLauncher</code></strong>: 特殊版本，旨在最小化共享测试用例的重复执行。</li>
</ul>
</li>
<li><strong><code>broker_hooks</code> (<code>libafl::events::broker_hooks</code>)</strong>:
<ul>
<li><strong>作用</strong>: 为 <strong>Broker 进程</strong>提供扩展机制，允许用户在 Broker 处理标准事件的流程中，通过<strong>挂载自定义代码 (Hooks)</strong> 来修改或增强 Broker 的行为。</li>
<li><strong><code>StdLlmpEventHook</code></strong>: 基于 LLMP 的 Broker 钩子具体实现。</li>
<li><strong>非处理特殊“钩子事件”</strong>: 而是为 Broker 的标准事件处理流程提供扩展点。</li>
</ul>
</li>
<li><strong><code>centralized</code> (<code>libafl::events::centralized</code>)</strong>:
<ul>
<li><strong>作用</strong>: 实现一种<strong>更高效的消息传递架构</strong>，通常采用<strong>主从 (main-secondary) 架构</strong>，可能与另一个 Broker 协同工作。</li>
<li><strong><code>CentralizedEventManager</code></strong>: 核心实现，作为包装器协调主从节点间的事件流。</li>
<li><strong>目标</strong>: 优化大规模 Fuzzing 集群中的消息路由和分发，减少通信开销。</li>
</ul>
</li>
<li><strong><code>events_hooks</code> (<code>libafl::events::events_hooks</code>)</strong>:
<ul>
<li><strong>作用</strong>: 允许用户在 <code>EventManager</code> <strong>尝试接收 (<code>try_receive</code>) 来自其他客户端的消息之前或之后</strong>，注入自定义的预处理或后处理代码。</li>
<li><strong>实现方式</strong>: 主要通过定义 <code>EventManagerHook</code> Trait，用户可自行实现具体钩子逻辑（如解密、校验、日志）。</li>
<li><strong>关注点</strong>: <code>EventManager</code> 的消息接收流程。</li>
</ul>
</li>
<li><strong><code>multi_machine</code> (<code>libafl::events::multi_machine</code>)</strong>:
<ul>
<li><strong>作用</strong>: 支持<strong>跨多台物理机器进行协同 Fuzzing</strong> 的组件。</li>
<li>核心功能:
<ul>
<li>基于 TCP 的跨机器通信 (<code>MultiMachineMsg</code>)。</li>
<li>节点管理与策略定义 (<code>NodeDescriptor</code>, <code>NodePolicy</code>)。</li>
<li>多机器 Broker 钩子 (<code>TcpMultiMachineHooks</code>)。</li>
<li>网络通信相关的状态管理 (<code>TcpMultiMachineState</code>)。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="feedback">feedback</h3>
<p><code>Feedback</code> 机制的核心作用是在目标程序每次执行后，<strong>分析来自 <code>Observer</code> (观察者) 的原始执行数据，并判断刚刚执行的输入是否“有趣” (is_interesting)</strong>。如果一个输入被判定为“有趣”，它通常会被添加到语料库 (<code>Corpus</code>) 中，作为后续输入变异的基础。它是覆盖率引导 Fuzzing 的关键。</p>
<p><strong>核心流程</strong>：</p>
<ol>
<li><code>Observer</code> 收集原始执行数据（如覆盖率、时间、比较日志等）。</li>
<li><code>Feedback</code> 分析这些数据。</li>
<li><code>Feedback</code> 返回一个布尔值 (<code>is_interesting</code>)，指示输入是否有价值。</li>
</ol>
<hr>
<p><strong>主要的 <code>Feedback</code> 类型与模块</strong></p>
<ul>
<li><strong>基于代码覆盖率 (<code>libafl::feedbacks::map</code>)</strong>:
<ul>
<li><strong><code>MaxMapFeedback</code></strong>: (常用) 配合边覆盖率观察者 (<code>HitcountsMapObserver</code>)，当输入触发新代码边或使边的命中次数进入新“桶”时，判定为有趣。目标是最大化覆盖。</li>
</ul>
</li>
<li><strong>基于执行退出类型 (<code>ExitKind</code>)</strong>:
<ul>
<li><strong><code>CrashFeedback</code></strong>: (常用) 当目标程序崩溃 (<code>ExitKind::Crash</code>) 时，判定为有趣。</li>
<li><strong><code>TimeoutFeedback</code></strong>: (常用) 当目标程序超时 (<code>ExitKind::Timeout</code>) 时，判定为有趣。</li>
<li><code>ExitKindFeedback</code>: 更通用的 <code>ExitKind</code> 检查反馈。</li>
<li><code>DiffExitKindFeedback</code>: 用于差分 Fuzzing，比较不同执行的 <code>ExitKind</code> 差异。</li>
</ul>
</li>
<li><strong>基于时间 (<code>libafl::feedbacks::TimeFeedback</code>)</strong>:
<ul>
<li>与 <code>TimeObserver</code> 配合，跟踪执行时间。可以将执行时间作为辅助反馈，或用于确保输入执行时间在合理范围内。</li>
</ul>
</li>
<li><strong>基于特定值/模式</strong>:
<ul>
<li><code>BoolValueFeedback</code>: 返回固定的 <code>true</code> 或 <code>false</code>。</li>
<li><code>NewHashFeedback</code>: 使用回溯哈希等判断案例是否新颖。</li>
<li><code>ValueBloomFeedback</code>: 使用布隆过滤器检查值是否新观察到。</li>
</ul>
</li>
<li><strong>特殊用途</strong>:
<ul>
<li><code>CaptureFeedback</code>: 捕获特定事件（如超时）的输入。</li>
<li><code>ConcolicFeedback</code>: 用于混合执行/符号执行。</li>
<li><code>NautilusFeedback</code>: 与 Nautilus 基于语法的 Fuzzer 配合。</li>
<li><code>CustomFilenameToTestcaseFeedback</code>: 自定义文件名与测试用例的关联。</li>
<li><code>DifferentialFeedback</code>: 比较两个同类型观察者的内容差异。</li>
<li><code>StdIoFeedback</code>: 基于标准输出/错误流的内容。</li>
<li><code>TransferredFeedback</code>: 检测测试用例是否从其他 Fuzzer 节点传输而来。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>核心要点回顾</strong>：</p>
<ul>
<li><code>Feedback</code> 是 Fuzzing 循环中进行决策的关键，它决定了哪些输入值得保留和进一步变异。</li>
<li>它将 <code>Observer</code> 收集的原始、复杂数据简化为“有趣”或“不有趣”的判断。</li>
<li>通过组合不同的 <code>Feedback</code>，可以构建出复杂的、多维度的输入评估标准。</li>
<li><code>MaxMapFeedback</code> (覆盖率) 和 <code>CrashFeedback</code> 是最基础和最重要的 Feedback 类型之一。</li>
</ul>
<h3 id="stages">stages</h3>
<p>在 LibAFL 中，一个 <strong><code>Stage</code></strong> 代表 Fuzzing 过程中的一个<strong>不同操作步骤或技术</strong>。它通常针对语料库 (<code>Corpus</code>) 中的单个输入（测试用例）进行处理，目的是分析、修改该输入，或者利用它来创造新的、有趣的测试用例，或为现有测试用例添加元数据。可以将 Fuzzing 过程看作一个流水线，每个 <code>Stage</code> 是流水线中的一个环节。</p>
<p><strong><code>Stage</code> Trait (核心接口)</strong>: 所有 Stage 都必须实现此接口，定义了一个 Fuzzing 步骤的核心逻辑，如 <code>perform(...)</code> 方法。</p>
<p><strong><code>StagesTuple</code> Trait</strong>: 允许将多个 Stage 组合在一起，按顺序对每个输入执行。</p>
<hr>
<p><strong>一、 主要的 <code>Stage</code> 类型/模块</strong></p>
<ul>
<li><strong><code>mutational</code> (变异阶段)</strong>:
<ul>
<li><strong>核心 Fuzzing 步骤</strong>：获取输入，使用 <code>Mutators</code> (变异器) 进行多次随机变异，执行变异后的输入，并由 <code>Feedbacks</code> (反馈) 评估是否“有趣” (如产生新覆盖或崩溃)。</li>
<li>示例：<code>StdMutationalStage</code>。</li>
</ul>
</li>
<li><strong><code>power</code> (能量调度阶段)</strong>:
<ul>
<li><strong>与能量调度配合</strong>：根据“能量”或优先级分配 Fuzzing 精力（如变异次数）给不同的输入。</li>
<li>通常在 <code>CalibrationStage</code> 之后。</li>
<li>示例：<code>StdPowerMutationalStage</code> (结合变异与能量调度)。</li>
</ul>
</li>
<li><strong><code>calibrate</code> (校准阶段)</strong>:
<ul>
<li><strong>初始度量</strong>：收集目标执行的初始指标，如平均执行时间、初始覆盖图状态/大小。</li>
<li>为后续的 Feedback 和 Scheduler 提供基准数据。</li>
</ul>
</li>
<li><strong><code>tracing</code> (追踪阶段)</strong>:
<ul>
<li><strong>收集元数据</strong>：追踪目标执行，用元数据（如 <code>CmpLog</code> 比较日志）丰富测试用例。</li>
<li>示例：<code>ShadowTracingStage</code> (常用于 QEMU 模式收集 CmpLog)。</li>
</ul>
</li>
<li><strong><code>shadow</code> (影子执行阶段)</strong>:
<ul>
<li><strong>并行追踪/观察</strong>：运行一个“影子”执行器和观察者，可以与进程内执行器一起使用。用于收集主执行路径之外的详细信息或不同类型的观察数据。</li>
</ul>
</li>
<li><strong><code>generation</code> (生成阶段)</strong>:
<ul>
<li><strong>从头创建输入</strong>：专注于生成单个新输入并评估，适用于基于语法或生成式 Fuzzing。</li>
<li>示例：<code>GenStage</code>。</li>
</ul>
</li>
<li><strong><code>tmin</code> (测试用例最小化阶段)</strong>:
<ul>
<li><strong>减小输入大小</strong>：尝试在保持输入“有趣”特性的前提下，最小化其大小。</li>
<li>示例：<code>StdTMinMutationalStage</code>。</li>
</ul>
</li>
<li><strong>同步阶段</strong>:
<ul>
<li><code>dump</code> (<code>DumpToDiskStage</code>): 将当前语料库和崩溃转储到磁盘，便于持久化或与其他 Fuzzer (如 AFL++) 同步。</li>
<li><code>sync</code> (<code>SyncFromDiskStage</code>): 从磁盘导入输入到语料库，用于同步或加载初始种子。</li>
</ul>
</li>
<li><strong>其他特定用途/工具类阶段</strong>:
<ul>
<li><code>afl_stats</code>: 计算和报告 AFL++ 风格的统计信息。</li>
<li><code>colorization</code>: 实现 AFL++ 的 &quot;colorization&quot; 技术 (与路径发现相关)。</li>
<li><code>concolic</code>: 支持混合执行 (具体执行 + 符号执行) 的阶段。</li>
<li><code>logics</code>: 阶段包装器，为阶段列表添加逻辑组合或条件。</li>
<li><code>push</code>: 返回输入而不是直接调用执行器，用于自定义流程。</li>
<li><code>replay</code>: 重新执行语料库中的所有输入一次。</li>
<li><code>time_tracker</code>: 包装另一个阶段以专门追踪其执行时间。</li>
<li><code>tuneable</code>: 变异迭代次数可在运行时动态调整的变异阶段。</li>
<li><code>unicode</code>: 分析 Unicode 风格输入常见变异的阶段。</li>
<li><code>verify_timeouts</code>: 重新运行超时输入以确认是否为真挂起 (通常配合 <code>CaptureTimeoutFeedback</code>)。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>二、 其他相关定义</strong></p>
<ul>
<li><strong><code>Structs</code> (结构体)</strong>:
<ul>
<li><code>ClosureStage</code>: 允许通过一个简单的闭包创建自定义 Stage。</li>
<li><code>ExecutionCountRestartHelper</code> / <code>RetryCountRestartHelper</code>: 用于管理需要特定执行次数或重试次数的 Stage，尤其在可重启场景下。</li>
<li><code>StageId</code>: Stage 的唯一标识符。</li>
</ul>
</li>
<li><strong><code>Traits</code> (接口)</strong>:
<ul>
<li><code>Restartable</code>: 定义 Stage 在 Fuzzer 重启时的行为规范，以恢复进度。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>核心要点回顾</strong>:</p>
<ul>
<li><code>Stage</code> 是 Fuzzing 循环中执行具体 Fuzzing 技术的操作单元。</li>
<li>LibAFL 提供多种预置 Stage，并允许用户自定义 Stage。</li>
<li>Stage 的顺序通常很重要，不同 Stage 协同工作以实现 Fuzzing 目标。</li>
<li>这种模块化设计使得用户可以灵活组合不同的技术来构建定制化的 Fuzzing 策略。</li>
</ul>
<h3 id="state">state</h3>
<p><code>State</code> 是 LibAFL Fuzzing 框架的<strong>核心数据中心和状态管理器</strong>。它在整个 Fuzzing 运行期间负责<strong>跟踪、存储和管理所有动态数据、配置以及 Fuzzing 进度</strong>。几乎所有其他 LibAFL 组件（如 <code>Fuzzer</code> 核心、<code>EventManager</code>、<code>Executor</code>、<code>Feedback</code>、<code>Corpus</code>、<code>Mutator</code>、<code>Stage</code>）都会与 <code>State</code> 进行交互。</p>
<p><strong><code>StdState</code> (标准状态实现)</strong>: 这是 LibAFL 中最常用、最标准的 <code>State</code> 具体实现。它包含 Fuzzing 运行所需的大部分标准组件和数据字段，例如：</p>
<ul>
<li><strong>随机数生成器 (<code>Rand</code>)</strong>: 为 Fuzzing 中的各种随机决策（选择输入、变异等）提供随机性。</li>
<li><strong>主语料库 (<code>Corpus</code>)</strong>: 存储和管理那些被 <code>Feedback</code> 机制认为是“有趣”的、能够触发新行为或覆盖的测试用例。这是 Fuzzer “学习”的基础。</li>
<li><strong>解决方案语料库 (<code>Solutions</code> corpus)</strong>: 专门用于存储那些导致目标程序崩溃、超时或其他被定义为“成功利用”或“目标达成”的输入。</li>
<li><strong>执行次数 (<code>Executions</code>)</strong>: 记录 Fuzzer 已经执行测试用例的总次数。</li>
<li><strong>Fuzzing 开始时间 (<code>StartTime</code>)</strong>: 记录 Fuzzing 会话的起始时间，用于计算运行总时长、执行速度等统计信息。</li>
<li>元数据映射 (<code>MetadataMap</code>): 一个非常灵活的键值存储，允许不同的组件在 <code>State</code> 中存储和共享自定义的、与状态相关的附加信息。例如：
<ul>
<li><code>Tokens</code> (用户提供的或 Fuzzer 学习到的“魔法数”)。</li>
<li><code>CmpLogObserver</code> 收集到的比较指令操作数值。</li>
<li>其他特定 Stage 或 Feedback 可能需要的临时或持久化数据。</li>
</ul>
</li>
<li><strong>当前测试用例信息</strong>: 存储当前正在被处理或 Fuzzing 的测试用例的相关信息。</li>
<li><strong>最大输入大小 (<code>MaxSize</code>)</strong>: 控制 Fuzzer 处理的输入的最大允许大小。</li>
</ul>
<hr>
<p><strong>核心 <code>State</code> 相关 Traits (接口/规范)</strong>:</p>
<p>LibAFL 大量使用 Traits 来定义 <code>State</code> 应具备的能力或应提供的信息，从而实现模块化和解耦。组件通过请求实现了特定 Trait 的 <code>State</code> 来工作，而不是依赖于某个具体的 <code>State</code> 类型。</p>
<ul>
<li><code>HasCorpus</code>: 表明 <code>State</code> 拥有或可以访问一个主语料库。</li>
<li><code>HasSolutions</code>: 表明 <code>State</code> 拥有或可以访问一个解决方案语料库。</li>
<li><code>HasRand</code>: 表明 <code>State</code> 拥有或可以访问一个随机数生成器。</li>
<li><code>HasExecutions</code>: 允许查询当前的执行次数。</li>
<li><code>HasStartTime</code>: 允许查询 Fuzzing 的开始时间。</li>
<li><code>HasMaxSize</code>: 允许查询和可能修改输入的最大大小。</li>
<li><code>HasClientPerfMonitor</code> / <code>MaybeHasClientPerfMonitor</code>: 提供客户端性能监视器。</li>
<li><code>HasCurrentStageId</code>: 跟踪当前执行的 Stage ID。</li>
<li><code>HasCurrentTestcase</code>: 持有当前正在处理的测试用例信息。</li>
<li><code>HasMetadata</code> (虽然未直接列在 <code>state</code> 模块顶级，但与 <code>MetadataMap</code> 紧密相关): 允许 <code>State</code> 存储和检索任意类型的元数据。</li>
<li><code>Stoppable</code>: 为 <code>State</code> 或相关组件提供一个检查是否应停止 Fuzzing 的API。</li>
</ul>
<hr>
<p><strong>其他相关结构体</strong>:</p>
<ul>
<li><code>LoadConfig</code>: 用于配置从磁盘加载初始种子时的选项。</li>
<li><code>NopState</code>: 极简的状态实现，主要用于测试。</li>
<li><code>StageStack</code>: 跟踪当前 Stage 的执行栈，用于处理嵌套 Stage。</li>
</ul>
<hr>
<p><strong>核心要点回顾</strong>:</p>
<ul>
<li><code>State</code> 是 Fuzzing 过程中的<strong>单一事实来源 (Single Source of Truth)</strong>，集中管理所有重要数据。</li>
<li><code>StdState</code> 是功能完备的标准实现，包含了大部分 Fuzzing 场景所需的字段和功能。</li>
<li>通过<strong>Traits</strong> (如 <code>HasCorpus</code>, <code>HasRand</code>)，LibAFL 实现了组件与 <code>State</code> 之间的松耦合，增强了框架的模块化、灵活性和可扩展性。不同的组件只依赖于它们需要的 <code>State</code> 能力，而不是具体的 <code>State</code> 类型。</li>
<li><code>MetadataMap</code> 为 <code>State</code> 提供了强大的扩展能力，允许动态添加和管理各种自定义数据。</li>
</ul>
<h3 id="mutator">Mutator</h3>
<p><strong>核心作用</strong>: <code>Mutator</code> 是 LibAFL Fuzzing 框架中负责<strong>对输入进行修改和转换以产生新测试用例的组件</strong>。它们是 Fuzzer 探索程序状态空间、尝试触发新行为和发现漏洞的主要手段。</p>
<p><strong>核心理念</strong>: 通过对现有输入应用一系列的变异操作，生成多样化的新输入，以期覆盖目标程序的更多代码路径并发现潜在的缺陷。</p>
<hr>
<p><strong>一、 <code>Mutator</code> Trait (核心接口)</strong></p>
<ul>
<li>定义了所有单一输入变异器的基本行为。</li>
<li>主要方法是 <code>mutate(...)</code>，它接收当前状态、要变异的输入和随机数生成器，并返回一个 <code>MutationResult</code> (指示变异是否成功以及输入是否被修改)。</li>
<li><code>MutatorsTuple</code> Trait: 允许将多个 <code>Mutator</code> 组合起来按顺序执行。</li>
</ul>
<hr>
<p><strong>二、 主要的 <code>Mutator</code> 类型/模块</strong></p>
<ul>
<li><strong>基础/通用变异 (<code>libafl::mutators::mutations</code>)</strong>:
<ul>
<li>提供大量字节级的基本变异操作，如位翻转、字节翻转、算术变异、数据块操作（删除、复制、交换）、拼接等。</li>
</ul>
</li>
<li><strong>Havoc 风格变异 (<code>libafl::mutators::havoc_mutations</code>)</strong>:
<ul>
<li>类似 AFL++ 的 Havoc 策略，组合多种基础变异，进行高随机性、高强度的变异，以快速产生差异较大的输入。</li>
</ul>
</li>
<li><strong>基于 Token 的变异 (<code>libafl::mutators::token_mutations</code>)</strong>:
<ul>
<li>利用 Fuzzer 状态中存储的 &quot;tokens&quot;（字典、魔法数、关键词）来指导变异，如插入 Token 或用 Token 替换输入部分。对特定格式或协议的输入非常有效。</li>
</ul>
</li>
<li><strong>调度型变异器 (<code>libafl::mutators::scheduled</code>)</strong>:
<ul>
<li><code>ScheduledMutator</code>: 内部可以包含一个变异器列表，并按某种策略（随机、顺序、权重）调度执行这些内部变异器，允许组合多种变异策略。</li>
</ul>
</li>
<li><strong>MOpt 变异调度器 (<code>libafl::mutators::mopt_mutator</code>)</strong>:
<ul>
<li><code>StdMOptMutator</code>: (常用) AFL++ 中引入的高级变异调度器，基于粒子群优化思想，尝试学习并动态调整选择哪些基础变异算子更有效。</li>
</ul>
</li>
<li><strong>语法感知型变异器</strong>:
<ul>
<li><code>gramatron</code>: 使用语法自动机进行变异，确保输入符合预定义语法。</li>
<li><code>nautilus</code>: 另一个基于语法的 Fuzzer 的变异器。</li>
</ul>
</li>
<li><strong>特定输入类型变异器</strong>:
<ul>
<li><code>encoded_mutations</code>: 针对 <code>EncodedInputs</code> (如 protobuf 编码的输入)。</li>
<li><code>list</code>: 针对列表形式的输入 (<code>ListInputs</code>)。</li>
<li><code>multi</code>: 针对由多个部分组成的输入 (<code>MultipartInputs</code>)。</li>
<li><code>numeric</code>: 针对整数类型输入的变异。</li>
<li><code>unicode</code>: 保留 Unicode 字符串类别的变异。</li>
</ul>
</li>
<li><strong>辅助/包装型变异器</strong>:
<ul>
<li><code>grimoire</code>: 基于学习输入结构并生成符合该结构的输入的策略。</li>
<li><code>hash</code>: 包装其他 Mutator，通过哈希比较确保输入确实发生改变。</li>
<li><code>mapping</code>: 允许混合和匹配不同的 Mutator 和 Input 类型。</li>
<li><code>tuneable</code>: <code>ScheduledMutator</code> 的扩展，允许运行时调整内部变异器的调度。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>三、 其他相关定义</strong></p>
<ul>
<li><strong><code>Structs</code> (结构体)</strong>:
<ul>
<li><code>BoolInvertMutator</code>: 反转布尔值的简单变异器。</li>
<li><code>NopMutator</code>: “空操作”变异器，用于测试。</li>
<li><code>MutationId</code>: 标识变异器元组中某个变异的索引。</li>
</ul>
</li>
<li><strong><code>Enums</code> (枚举)</strong>:
<ul>
<li><code>MutationResult</code>: 表示变异操作的结果 (<code>Mutated</code>, <code>Skipped</code>, <code>Invalid</code>)。</li>
</ul>
</li>
<li><strong><code>Traits</code> (接口)</strong>:
<ul>
<li><code>MultiMutator</code>: 一次接收一个输入，返回多个变异后输入的变异器。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>核心要点回顾</strong>:</p>
<ul>
<li><strong>生成新输入的引擎</strong>: <code>Mutator</code> 是 Fuzzing 过程中产生新测试用例的核心。</li>
<li><strong>多样性</strong>: LibAFL 提供了从基础字节操作到高级上下文感知策略的丰富变异器。</li>
<li><strong>组合与调度是关键</strong>: 通过 <code>ScheduledMutator</code>、<code>MutatorsTuple</code> 或像 <code>StdMOptMutator</code> 这样的高级调度器，可以将多种变异策略组合起来以增强效果。</li>
<li><strong>上下文感知</strong>: 一些高级变异器会利用从 Fuzzing 过程中学习到的信息（如 Tokens、CmpLog 结果）来指导变异，使其更具目标性。</li>
<li><strong>适应性</strong>: 针对不同的输入类型（如结构化数据、数值、字符串）和目标程序特性，选择或定制合适的变异器组合是提高 Fuzzing 效率的关键。</li>
</ul>
<h3 id="scheduler">scheduler</h3>
<p><code>Scheduler</code> 决定了 Fuzzer <strong>如何以及按什么顺序从语料库 (<code>Corpus</code>) 中选择下一个测试用例 (Testcase) 进行 Fuzzing</strong>。一个好的调度策略能够显着影响 Fuzzing 的效率，它可以优先选择那些更有可能发现新代码路径或触发漏洞的输入。</p>
<p><strong>核心理念</strong>: 通过智能地选择和排序语料库中的输入，最大化 Fuzzing 的效果，避免在低价值的输入上浪费过多的时间和计算资源。</p>
<hr>
<p><strong>一、 <code>Scheduler</code> Trait (核心接口)</strong></p>
<ul>
<li>定义了所有调度器的基本行为。</li>
<li>核心方法是 <code>next()</code>，用于从语料库中请求下一个要处理的测试用例的索引。</li>
<li>包含钩子方法，如 <code>on_add</code> (当新测试用例添加到语料库时调用)、<code>on_remove</code> (当测试用例从语料库移除时调用，需要实现 <code>RemovableScheduler</code> Trait)、<code>on_replace</code> (当测试用例被替换时调用，需要实现 <code>RemovableScheduler</code> Trait)，这些钩子允许调度器在语料库发生变化时收集数据或更新其内部状态，以支持复杂的调度算法。</li>
</ul>
<hr>
<p><strong>二、 主要的 <code>Scheduler</code> 类型/模块</strong></p>
<ul>
<li><strong><code>queue</code> (队列调度器)</strong>:
<ul>
<li><strong>AFL 风格队列机制</strong>: 实现类似于经典 AFL 的队列机制，通常是先进先出 (FIFO) 或有一些简单的优先级策略。</li>
<li>示例: <code>QueueScheduler</code> (虽然文档中未直接列出，但 <code>StdScheduler</code> 通常基于此)。</li>
</ul>
</li>
<li><strong><code>powersched</code> (能量调度器)</strong>:
<ul>
<li><strong>基于能量分配</strong>: 结合“能量调度”(Power Schedules) 算法。这种算法会为语料库中的每个输入分配一定的“能量”，能量越高的输入会被更频繁地选中或进行更多的变异。能量的分配通常基于输入的效果（如发现新覆盖、执行时间等）。</li>
<li>你的 Fuzzer 代码中，<code>PowerQueueScheduler</code> 就是这类调度器的代表。</li>
</ul>
</li>
<li><strong><code>minimizer</code> (最小化调度器)</strong>:
<ul>
<li><strong>子集选择</strong>: 这类调度器只从整个语料库的一个子集中选择测试用例提供给 Fuzzer。</li>
<li><strong>目的</strong>: 可能用于专注 Fuzzing 语料库中特定的一部分，或者与测试用例最小化策略配合，只使用最小化后的核心语料。</li>
</ul>
</li>
<li><strong><code>accounting</code> (覆盖率审计调度器)</strong>:
<ul>
<li><strong>基于详细覆盖率分析</strong>: 这种调度器会进行更细致的覆盖率审计，以确保 Fuzzer 在所有已发现的路径上都花费了足够的精力，并优先探索那些能够覆盖到“稀有”或“昂贵”路径的输入。</li>
<li>引用了 NDSS 的论文，表明其背后有学术研究支持。</li>
</ul>
</li>
<li><strong><code>probabilistic_sampling</code> (概率采样调度器)</strong>:
<ul>
<li><strong>随机抽样</strong>: 从语料库中按一定概率随机抽取测试用例。可以引入更多随机性，但也可能不如基于覆盖率或能量的调度器高效。</li>
</ul>
</li>
<li><strong><code>testcase_score</code> (测试用例评分)</strong>:
<ul>
<li><strong>为输入打分</strong>: 提供一种评估机制，为语料库中的每个条目（测试用例）打分。这个分数可以被其他调度器用来决定选择哪个输入。</li>
</ul>
</li>
<li><strong><code>tuneable</code> (可调队列调度器)</strong>:
<ul>
<li><strong>扩展队列调度器</strong>: 在 AFL 风格队列调度器的基础上，增加了手动选择下一个语料库条目的方法，提供了更灵活的控制。</li>
</ul>
</li>
<li><strong><code>weighted</code> (加权队列调度器)</strong>:
<ul>
<li><strong>AFL++ 风格</strong>: 类似于 AFL++ 中的加权队列，可能会根据输入的某些属性（如大小、发现时间、是否触发新行为等）给予不同的权重，影响其被选中的概率。</li>
</ul>
</li>
<li><strong><code>RandScheduler</code> (随机调度器)</strong> (位于 <code>Structs</code>):
<ul>
<li><strong>纯随机选择</strong>: 简单地从语料库中随机选择一个测试用例。这是最基础的调度方式。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>三、 其他相关定义</strong></p>
<ul>
<li><strong><code>Traits</code> (接口)</strong>:
<ul>
<li><code>AflScheduler</code>: 为 AFL 风格的调度器定义通用的元数据操作。</li>
<li><code>HasQueueCycles</code>: 标记那些跟踪“队列周期”（完整遍历一遍语料库的次数）的调度器。</li>
<li><code>RemovableScheduler</code>: 扩展了 <code>Scheduler</code> Trait，增加了 <code>on_remove</code> 和 <code>on_replace</code> 钩子，用于在语料库条目被移除或替换时通知调度器。</li>
</ul>
</li>
<li><strong><code>Functions</code> (函数)</strong>:
<ul>
<li><code>on_add_metadata_default</code>, <code>on_evaluation_metadata_default</code>, <code>on_next_metadata_default</code>: 这些可能是为 <code>Scheduler</code> Trait 中的钩子方法提供的默认实现或辅助函数，用于处理与测试用例元数据相关的操作。</li>
</ul>
</li>
<li><strong><code>Type Aliases</code> (类型别名)</strong>:
<ul>
<li><code>StdScheduler</code>: <strong>LibAFL 中默认使用的标准调度器类型</strong>。它通常是一个经过良好配置和优化的调度器实现（例如，可能是基于队列和能量调度的组合）。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>核心要点回顾</strong>:</p>
<ul>
<li><code>Scheduler</code> 的核心任务是从语料库中<strong>选择下一个要 Fuzz 的输入</strong>。</li>
<li>不同的调度策略会显着影响 Fuzzing 的方向和效率。</li>
<li>LibAFL 提供了多种调度器实现，从简单的随机选择到复杂的基于能量、覆盖率审计或评分的策略。</li>
<li>许多调度器通过实现 <code>Scheduler</code> Trait 中的钩子方法（如 <code>on_add</code>）来动态适应语料库的变化。</li>
<li><code>StdScheduler</code> 是 LibAFL 推荐的默认调度器。</li>
<li>你的 Fuzzer 中使用了 <code>IndexesLenTimeMinimizerScheduler</code> 包装 <code>PowerQueueScheduler</code>，这是一种结合了输入最小化、长度/时间考量以及能量调度的先进策略。</li>
</ul>
<h3 id="fuzzer">Fuzzer</h3>
<p><code>Fuzzer</code> 结构体是整个 Fuzzing 活动 (fuzz campaign) 的<strong>主要控制中心和执行者</strong>。它将所有其他核心组件（如 <code>State</code>, <code>EventManager</code>, <code>Executor</code>, <code>Feedback</code>, <code>Scheduler</code>, <code>Stages</code>）有机地组织和驱动起来，以执行完整的 Fuzzing 循环。</p>
<hr>
<p><strong>一、 核心结构体 (<code>Structs</code>)</strong></p>
<ul>
<li><strong><code>StdFuzzer</code></strong>:
<ul>
<li><strong>描述</strong>: 这是 LibAFL 提供的<strong>默认、标准的 Fuzzer 实例</strong>，适用于大多数日常 Fuzzing 任务.</li>
<li><strong>作用</strong>: 它封装了 Fuzzing 的主循环逻辑，包括从调度器 (<code>Scheduler</code>) 获取下一个要测试的输入，执行该输入（通过 <code>Executor</code>），评估执行结果（通过 <code>Feedback</code> 和 <code>Observers</code>），并将有趣的输入添加回语料库 (<code>Corpus</code>)。</li>
</ul>
</li>
<li><strong><code>NopFuzzer</code></strong>:
<ul>
<li><strong>描述</strong>: 一个“空操作”的 Fuzzer，它不执行任何实际的 Fuzzing 操作.</li>
<li><strong>作用</strong>: 主要用于测试或作为不需要实际 Fuzzing 时的占位符。</li>
</ul>
</li>
<li><strong><code>BloomInputFilter</code></strong>:
<ul>
<li><strong>描述</strong>: 一种基于布隆过滤器 (Bloom Filter) 的输入过滤器，用于<strong>概率性地防止重复执行相同的输入</strong>.</li>
<li><strong>作用</strong>: 布隆过滤器是一种空间效率高的数据结构，可以用来判断一个元素是否“可能”在一个集合中。在这里，它可以快速地判断一个输入是否与之前执行过的输入相似或相同，从而避免不必要的重复执行，提高 Fuzzing 效率。</li>
</ul>
</li>
<li><strong><code>NopInputFilter</code></strong>:
<ul>
<li><strong>描述</strong>: 一个伪过滤器，它会允许执行每一个输入，即不进行任何过滤.</li>
<li><strong>作用</strong>: 当不需要输入过滤功能时使用。</li>
</ul>
</li>
<li><strong><code>ExecuteInputResult</code></strong>:
<ul>
<li><strong>描述</strong>: 表示执行一个输入后的结果，特别是指示这个输入应该被添加到哪个语料库。例如，是添加到主语料库还是解决方案语料库。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>二、 核心 Traits (接口/规范)</strong></p>
<p>这些 Trait 定义了 <code>Fuzzer</code> 及其相关组件应具备的核心能力和职责。</p>
<ul>
<li><strong><code>Fuzzer</code></strong>:
<ul>
<li><strong>描述</strong>: <strong>最主要的 Fuzzer Trait</strong>，定义了 Fuzzer 的基本行为和驱动整个 Fuzzing 过程的能力。它通常包含启动 Fuzzing 循环 (<code>fuzz_loop</code>)、单步执行 (<code>fuzz_one</code>) 等核心方法。</li>
</ul>
</li>
<li><strong><code>Evaluator</code> / <code>EvaluatorObservers</code></strong>:
<ul>
<li><strong>描述</strong>: <code>Evaluator</code> 定义了评估一个输入并相应修改 Fuzzer 状态的行为。<code>EvaluatorObservers</code> 可能是 <code>Evaluator</code> 的一个变种或辅助 Trait，强调了在评估过程中对观察者 (<code>Observers</code>) 的使用。</li>
<li><strong>作用</strong>: 在输入执行后，根据 <code>Feedback</code> 和 <code>Observers</code> 的结果来判断输入是否有趣，并决定是否将其加入语料库、更新状态等。</li>
</ul>
</li>
<li><strong><code>EventProcessor</code></strong>:
<ul>
<li><strong>描述</strong>: 定义了从 <code>EventManager</code> 接收事件并对其进行评估处理的能力。</li>
<li><strong>作用</strong>: 在分布式或多进程 Fuzzing 中，Fuzzer 需要能够接收和处理来自其他 Fuzzer 实例或 Broker 的事件（如新的测试用例）。</li>
</ul>
</li>
<li><strong><code>ExecutesInput</code></strong>:
<ul>
<li><strong>描述</strong>: 标记那些能够执行输入的结构体。</li>
<li><strong>作用</strong>: <code>Fuzzer</code> 自身通常会实现这个 Trait，因为它负责驱动输入的执行。</li>
</ul>
</li>
<li><strong><code>ExecutionProcessor</code></strong>:
<ul>
<li><strong>描述</strong>: 定义了使用 <code>Feedback</code> 来评估一个输入是否有趣的行为。</li>
<li><strong>作用</strong>: 这是 <code>Fuzzer</code> 判断输入价值的核心逻辑部分，紧密关联 <code>Feedback</code> 机制。</li>
</ul>
</li>
<li><strong><code>HasFeedback</code></strong>:
<ul>
<li><strong>描述</strong>: 表明一个结构体（通常是 <code>Fuzzer</code> 或 <code>State</code>）持有一个或多个 <code>Feedback</code> 实例。</li>
</ul>
</li>
<li><strong><code>HasObjective</code></strong>:
<ul>
<li><strong>描述</strong>: 表明一个结构体持有一个“目标” Feedback (<code>ObjectiveFeedback</code>)。目标 Feedback 通常用于判断是否达到了 Fuzzing 的最终目标（如发现崩溃）。</li>
</ul>
</li>
<li><strong><code>HasScheduler</code></strong>:
<ul>
<li><strong>描述</strong>: 表明一个结构体持有一个 <code>Scheduler</code> (调度器) 实例。调度器负责决定下一个应该从语料库中选择哪个输入进行 Fuzzing。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>核心要点回顾</strong>:</p>
<ul>
<li><code>Fuzzer</code> (特别是 <code>StdFuzzer</code>) 是 LibAFL 的<strong>指挥中心</strong>，它整合了所有其他组件（State, EventManager, Executor, Feedback, Scheduler, Stages）来执行 Fuzzing 任务。</li>
<li>它负责驱动 Fuzzing 循环，包括选择输入、执行输入、评估结果、更新语料库和状态。</li>
<li>通过一系列 Traits (如 <code>Evaluator</code>, <code>EventProcessor</code>, <code>ExecutesInput</code>)，<code>Fuzzer</code> 的行为和职责被清晰地定义和模块化。</li>
<li>输入过滤器 (如 <code>BloomInputFilter</code>) 可以帮助提高效率，避免重复工作。</li>
</ul>
<h3 id="executors">executors</h3>
<p><code>Executor</code> 是 LibAFL Fuzzing 框架中负责<strong>接收输入 (Input)，并在目标程序中实际执行这个输入</strong>的组件。它是 Fuzzer 与被测目标交互的桥梁，负责启动目标、传递输入、监控执行过程，并最终报告执行结果（如 <code>ExitKind</code>：正常退出、崩溃、超时等）。</p>
<p><strong>核心理念</strong>: <code>Executor</code> 的核心任务是将 Fuzzer 生成的或选择的输入“喂”给目标程序，并观察其行为。LibAFL 提供了多种 <code>Executor</code> 实现，以适应不同的目标程序类型（如命令行工具、库函数、QEMU 模拟的程序）和不同的 Fuzzing 策略（如进程内执行、基于 fork/forkserver 的执行、差分 Fuzzing 等）。</p>
<hr>
<p><strong>一、 <code>Executor</code> Trait (核心接口)</strong></p>
<ul>
<li>定义了所有执行器的基本行为和契约。</li>
<li>其核心方法通常是 <code>run_target(...)</code> 或类似名称，该方法接收一个输入，在目标程序中执行它，并返回一个 <code>ExitKind</code> 来指示执行是如何结束的。</li>
</ul>
<hr>
<p><strong>二、 主要的 <code>Executor</code> 类型/模块</strong></p>
<ol>
<li><strong><code>inprocess</code> (进程内执行器)</strong>:
<ul>
<li><strong><code>InProcessExecutor</code></strong>: 类似 libFuzzer，直接在 Fuzzer 自身的进程空间内调用一个目标函数 (harness function)。</li>
<li><strong>优点</strong>: 速度快，无进程切换开销。</li>
<li><strong>缺点</strong>: 目标崩溃会导致 Fuzzer 进程一同崩溃，通常需要配合可重启的事件管理器 (<code>RestartingEventManager</code>)。</li>
</ul>
</li>
<li><strong><code>inprocess_fork</code> (进程内 Fork 执行器)</strong>:
<ul>
<li><strong><code>GenericInProcessForkExecutor</code></strong>: 在每次执行 harness 函数前，Fuzzer 主进程会调用 <code>fork()</code> 创建一个子进程，实际的目标函数调用在子进程中进行。</li>
<li><strong>优点</strong>: 目标崩溃仅影响子进程，主 Fuzzer 安全。</li>
<li><strong>缺点</strong>: 每次 <code>fork()</code> 仍有开销，通常比 <code>forkserver</code> 慢。</li>
</ul>
</li>
<li><strong><code>forkserver</code> (Forkserver 执行器)</strong>:
<ul>
<li><strong>AFL 经典模式</strong>: 目标程序启动后进入一个特殊的 &quot;forkserver&quot; 模式。Fuzzer 命令此服务器 <code>fork()</code> 子进程来执行每个输入。</li>
<li><strong>优点</strong>: 目标程序的核心初始化仅发生一次，后续 <code>fork()</code> 开销极小，效率高。</li>
<li><strong>适用性</strong>: 通常需要目标程序经过 AFL 工具链插桩以支持 forkserver。</li>
</ul>
</li>
<li><strong><code>command</code> (命令执行器)</strong>:
<ul>
<li><strong>执行外部程序</strong>: 为每次运行启动一个独立的子程序（如命令行工具），通过标准输入、文件或命令行参数传递输入。</li>
<li><strong>适用性</strong>: Fuzz 独立的命令行应用。</li>
</ul>
</li>
<li><strong><code>differential</code> (差分执行器)</strong>:
<ul>
<li><strong>比较不同版本</strong>: 同时或先后执行两个或多个不同版本/配置的目标程序，并比较它们的行为差异。</li>
<li><strong>目标</strong>: 发现回归性 bug 或版本间的行为不一致。</li>
</ul>
</li>
<li><strong><code>combined</code> (组合执行器)</strong>:
<ul>
<li><strong><code>CombinedExecutor</code></strong>: 包装一个主执行器和一个次执行器，但次执行器不在 <code>run_target</code> 中执行。用于主副执行器逻辑分离的特定场景。</li>
</ul>
</li>
<li><strong><code>shadow</code> (影子执行器)</strong>:
<ul>
<li><strong><code>ShadowExecutor</code></strong>: 包装一个主执行器，目的是配合一组**“影子观察者” (Shadow Observers)** 工作。</li>
<li><strong>影子观察者</strong>: 任何标准的 <code>Observer</code> (如 <code>CmpLogObserver</code>) 都可以作为影子观察者，它们收集的信息<strong>不直接</strong>用于主 <code>Feedback</code> 循环的决策。</li>
<li><strong>作用</strong>: 允许在不干扰核心 Fuzzing 逻辑的情况下，独立收集额外的、可能更专门或开销更大的观测数据（例如，<code>CmpLog</code> 数据用于指导后续变异）。</li>
<li><strong>“影子”含义</strong>: 指的是一种并行但独立于主反馈决策流程的观察路径。</li>
</ul>
</li>
<li><strong><code>hooks</code> (执行器钩子)</strong>:
<ul>
<li><strong>扩展执行流程</strong>: 提供在执行器运行 harness 函数之前和之后插入自定义代码的钩子点。</li>
</ul>
</li>
<li><strong><code>sand</code> (SAND 执行器)</strong>:
<ul>
<li><strong>低开销污点分析解耦</strong>: 实现 SAND 技术，旨在将动态分析（如 Sanitizer）的开销与 Fuzzing 主循环分离开，以提高 Fuzzing 效率。</li>
</ul>
</li>
<li><strong><code>with_observers</code> (带观察者的执行器包装器)</strong>:
<ul>
<li><strong>添加 <code>HasObservers</code> 能力</strong>: 包装任何 <code>Executor</code>，使其能够持有观察者元组 (<code>ObserversTuple</code>) 并实现 <code>HasObservers</code> Trait。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>三、 核心枚举 (<code>Enums</code>)</strong></p>
<ul>
<li><strong><code>ExitKind</code></strong>:
<ul>
<li><strong>指示执行结果</strong>: 目标程序一次执行的结束状态。</li>
<li><strong>常见类型</strong>: <code>Ok</code> (正常), <code>Crash</code> (崩溃), <code>Timeout</code> (超时), <code>OOM</code> (内存溢出)。</li>
</ul>
</li>
<li><strong><code>DiffExitKind</code></strong>:
<ul>
<li><strong>用于差分 Fuzzing</strong>: 描述差分执行中某个版本的具体退出类型。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>四、 核心 Traits (接口/规范)</strong></p>
<ul>
<li><strong><code>Executor</code></strong>: 主要执行器接口，定义执行输入的核心功能。</li>
<li><strong><code>ExecutorsTuple</code></strong>: 允许组合多个执行器。</li>
<li><strong><code>HasObservers</code></strong>: 表明执行器持有观察者。<code>Executor</code> 在执行后会通知 <code>Observer</code> 收集信息。</li>
<li><strong><code>HasTimeout</code></strong>: 允许获取或设置 <code>Executor</code> 的超时阈值。</li>
</ul>
<hr>
<p><strong>五、 辅助函数 (<code>Functions</code>)</strong></p>
<ul>
<li><code>common_signals</code>: 可能包含 Fuzzer 希望处理的常见操作系统信号列表。</li>
</ul>
<hr>
<p><strong>核心要点回顾</strong>:</p>
<ul>
<li><code>Executor</code> 是<strong>实际运行目标程序并应用输入</strong>的组件。</li>
<li>LibAFL 提供多种 <code>Executor</code> 以适应不同目标和策略。</li>
<li><code>ExitKind</code> 是报告执行结果的关键。</li>
<li><code>Executor</code> 与 <code>Observers</code> 紧密协作，在执行后由 <code>Observers</code> 收集数据。</li>
<li><code>forkserver</code> vs <code>inprocess_fork</code>:
<ul>
<li><code>inprocess_fork</code>: Fuzzer 主进程每次都 <code>fork()</code>，子进程调用 harness。</li>
<li><code>forkserver</code>: 目标程序自身变成 fork 服务器，Fuzzer 命令它 <code>fork()</code>，初始化开销小，效率通常更高。</li>
</ul>
</li>
<li><code>ShadowExecutor</code> 与 <code>Shadow Observers</code>:
<ul>
<li><code>ShadowExecutor</code> 允许一组“影子观察者”独立于主反馈循环收集额外数据。</li>
<li>任何 <code>Observer</code> 都可以充当影子观察者，如 <code>CmpLogObserver</code>，其数据主要用于指导后续变异而非立即的“有趣性”判断。</li>
</ul>
</li>
</ul>
<h2 id="libafl简短介绍">LibAFL简短介绍</h2>
<p>方便向面试官讲解的，感觉写的还是不够通俗，很多面试官其实并不了解，甚至有的不知道模糊测试的概念，后续可能也应该添加上</p>
<p>LibAFL是一个Fuzz框架，它的核心理念是模块化、可组合性、高性能、可扩展性。</p>
<p>它主要是提供了一个灵活的框架，让我们可以方便地构建定制化的 Fuzzer，而不需要从零开始。</p>
<ol>
<li>
<p>Fuzzer</p>
<p>最核心的部分是Fuzzer，是整个 Fuzzing 活动 (fuzz campaign) 的<strong>主要控制中心和执行者</strong>。它将所有其他核心组件有机地组织和驱动起来，以执行完整的 Fuzzing 循环。</p>
<p>以<code>StdFuzzer</code>为例，这也是LibAFL提供的一个默认、标准的Fuzzer实例，主要的流程就是从调度器 (<code>Scheduler</code>) 获取下一个要测试的输入，执行该输入（通过 <code>Executor</code>），评估执行结果（通过 <code>Feedback</code> 和 <code>Observers</code>），并将有趣的输入添加回语料库 (<code>Corpus</code>)。</p>
<p>但虽然创建的时候，标准StdFuzzer的new方法需要的三个参数为我刚刚说的scheduler, feedback, objective，但具体循环执行的loop方法中，其实用到了更顶层的一些模块，比如stages、executor、state、eventmanager</p>
<p>让我们先从state说起</p>
</li>
<li>
<p>state</p>
<p><code>State</code> 是 LibAFL Fuzzing 框架的<strong>核心数据中心和状态管理器</strong>。它在整个 Fuzzing 运行期间负责<strong>跟踪、存储和管理所有动态数据、配置以及 Fuzzing 进度</strong>。几乎所有其他 LibAFL 组件（如 <code>Fuzzer</code> 核心、<code>EventManager</code>、<code>Executor</code>、<code>Feedback</code>、<code>Corpus</code>、<code>Mutator</code>、<code>Stage</code>）都会与 <code>State</code> 进行交互。</p>
</li>
<li>
<p>stages</p>
<p>一个 <strong><code>Stage</code></strong> 代表 Fuzzing 过程中的一个<strong>不同操作步骤或技术</strong>。它通常针对语料库 (<code>Corpus</code>) 中的单个输入（测试用例）进行处理，目的是分析、修改该输入，或者利用它来创造新的、有趣的测试用例，或为现有测试用例添加元数据。可以将 Fuzzing 过程看作一个流水线，每个 <code>Stage</code> 是流水线中的一个环节。</p>
<p>这里有很多有趣的部分，最常见的就是</p>
<ul>
<li>mutational变异阶段，核心步骤就是获取输入，使用 <code>Mutators</code> (变异器) 进行多次随机变异，执行变异后的输入，并由 <code>Feedbacks</code> (反馈) 评估是否“有趣” (如产生新覆盖或崩溃)。</li>
<li>其他还有power，它可以根据“能量”或优先级分配 Fuzzing 精力（如变异次数）给不同的输入，一般在 <code>Calibration Stage</code> 之后。</li>
<li>至于calibrate，主要就是收集目标执行的初始指标，如平均执行时间、初始覆盖图状态/大小，为后续的 Feedback 和 Scheduler 提供基准数据。</li>
<li>其他还有<code>tracing</code>， 追踪目标执行，用元数据（如 <code>CmpLog</code> 比较日志）丰富测试用例。</li>
<li><code>shadow</code>，这个我用的不多，感觉主要就是独立于主执行路径之外，一般我配合cmplog用</li>
<li><code>generation</code>，生成新输入</li>
</ul>
</li>
<li>
<p>eventsmanager</p>
<p><code>EventManager</code> 是 LibAFL 中负责<strong>通信和协调</strong>的核心组件。它管理 Fuzzer 实例之间或 Fuzzer 内部组件之间的<strong>事件流</strong>。这些事件可以是新发现的测试用例、代码覆盖信息、统计数据、崩溃报告、日志消息等。</p>
<ul>
<li>最简单的就是simple，主要用来日志输出</li>
<li>别的感觉用来多线程或者多个物理机同步多一点</li>
<li>还有Launcher，用来<strong>并行启动和管理多个 Fuzzer 实例</strong>的</li>
<li>其他就是实现主从架构的多一点</li>
</ul>
</li>
<li>
<p>还有scheduler，Fuzzer新建实例的时候的必需品</p>
<p><code>Scheduler</code> 决定了 Fuzzer <strong>如何以及按什么顺序从语料库 (<code>Corpus</code>) 中选择下一个测试用例 (Testcase) 进行 Fuzzing</strong>。我认为它核心的理念就是通过智能地选择和排序语料库中的输入，最大化 Fuzzing 的效果，避免在低价值的输入上浪费过多的时间和计算资源。</p>
<ul>
<li>最简单的就是queue，对列调度，先进先出嘛</li>
<li>还有power，能量调度，给语料库输入根据覆盖率还有执行时间什么的分配能量，按能量提高输入被选中的概率</li>
<li>accounting 进行更细致的覆盖率审计，以确保 Fuzzer 在所有已发现的路径上都花费了足够的精力，并优先探索那些能够覆盖到“稀有”或“昂贵”路径的输入。</li>
<li>还有纯靠概率的，提高随机性</li>
<li>其他好像还有打分的，加权的，差不多就这些吧</li>
</ul>
</li>
<li>
<p>executor</p>
<p>LibAFL中接收输入 (Input)，并在目标程序中实际执行这个输入的组件，我觉得还是起一个桥梁作用，负责启动目标、传递输入、监控执行过程，并最终报告执行结果</p>
<ul>
<li>
<p>具体来说，感觉就三种最常用的，比如InProcessExecutor，类似 libFuzzer，直接在 Fuzzer 自身的进程空间内调用一个目标函数 (harness function)。速度快，无进程切换开销，但目标崩溃会导致 Fuzzer 进程一同崩溃，通常需要配合可重启的事件管理器</p>
</li>
<li>
<p>InprocessForkExecutor</p>
<p>每次执行 harness 函数前，Fuzzer 主进程会调用 <code>fork()</code> 创建一个子进程，实际的目标函数调用在子进程中进行。这就让目标崩溃只影响子进程，但每次 <code>fork()</code> 仍有开销，通常比 <code>forkserver</code> 慢。</p>
</li>
<li>
<p>forkserver</p>
<p>目标程序启动后进入一个特殊的 &quot;forkserver&quot; 模式。Fuzzer 命令此服务器 <code>fork()</code> 子进程来执行每个输入。目标程序的核心初始化仅发生一次，后续 <code>fork()</code> 开销极小，效率高。</p>
</li>
</ul>
<p>别的好像用的就不是很多了，哦，还有shadow，配合shadow observer工作，用来指导变异</p>
<p>别的好像就剩observer跟monitor、feedback了</p>
</li>
<li>
<p>monitor</p>
<p>最好说，就是显示信息嘛</p>
</li>
<li>
<p>observer</p>
<p>主要用来观察，最重要的当然是</p>
<ul>
<li>
<p>map</p>
<p>map observer主要观察一块共享内存区域（“地图”），这块地图由被<strong>插桩的目标程序</strong>在执行时更新，用以记录代码执行信息，最常见的是<strong>代码覆盖率</strong>。</p>
</li>
<li>
<p>其他还有cmp，就是记录cmplog，然后结合上面的executor对Mutator做指导，比如我们程序比较A=B的时候，它会偷偷把A跟B记下来，马上输入直接给你换成A或者B这样</p>
</li>
<li>
<p>还有concolic，符号化执行与具体执行相结合，记录执行路径，然后求解分析条件，找到新值</p>
</li>
</ul>
</li>
<li>
<p>哦，还有Mutator，对输入进行修改和转换</p>
<ul>
<li>基础的就是字节基本变异</li>
<li>还有havoc变异</li>
<li>别的就是基于token的变异，这里可以配合cmplog进行</li>
<li>别的还有mopt变异</li>
<li>还有语法感知变异</li>
<li>还有学习输入结构，生成符合结构的变异输入</li>
</ul>
</li>
<li>
<p>还有feedback，判断输入是否有趣的</p>
</li>
</ol>
<ul>
<li>基于代码覆盖率</li>
<li>基于执行退出</li>
<li>基于时间</li>
<li>基于特定值/模式</li>
</ul>

<span id="footnote"></span>
<div id = "warn"></div>
</div>
<div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#tokens">tokens</a></li>
<li><a href="#duration">Duration</a></li>
<li><a href="#module">module</a></li>
</ul>
</li>
<li><a href="#%E5%85%B7%E4%BD%93%E6%A8%A1%E5%9D%97">具体模块</a>
<ul>
<li><a href="#observer">observer</a>
<ul>
<li><a href="#cmp">cmp</a></li>
<li><a href="#concolic">concolic</a></li>
<li><a href="#map">map</a></li>
</ul>
</li>
<li><a href="#monitor">monitor</a></li>
<li><a href="#events">events</a></li>
<li><a href="#feedback">feedback</a></li>
<li><a href="#stages">stages</a></li>
<li><a href="#state">state</a></li>
<li><a href="#mutator">Mutator</a></li>
<li><a href="#scheduler">scheduler</a></li>
<li><a href="#fuzzer">Fuzzer</a></li>
<li><a href="#executors">executors</a></li>
</ul>
</li>
<li><a href="#libafl%E7%AE%80%E7%9F%AD%E4%BB%8B%E7%BB%8D">LibAFL简短介绍</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="fullPage"><canvas id="canvas"></canvas></div>
</article>
<div id="eof"><span>EOF</span></div><div class="round-shape-one"></div>
<section>
<div class="doc_comments">

</div></section>
</div></div></div><script>
"use strict";!function(){for(var n=document.getElementsByTagName("pre"),e=n.length,s=0;s<e;s++){n[s].innerHTML='<span class="line-number"></span>'+n[s].innerHTML+'<span class="cl"></span>';for(var a=n[s].innerHTML.split(/\n/).length,r=0;r<a-1;r++){n[s].getElementsByTagName("span")[0].innerHTML+="<span>"+(r+1)+"</span>"}}}();
let mainNavLinks=document.querySelectorAll(".markdownIt-TOC a");window.addEventListener("scroll",event=>{let fromTop=window.scrollY;mainNavLinks.forEach((link,index)=>{let section=document.getElementById(decodeURI(link.hash).substring(1));let nextSection=null
if(mainNavLinks[index+1]){nextSection=document.getElementById(decodeURI(mainNavLinks[index+1].hash).substring(1));}
if(section.offsetTop<=fromTop){if(nextSection){if(nextSection.offsetTop>fromTop){link.classList.add("currentToc");}else{link.classList.remove("currentToc");}}else{link.classList.add("currentToc");}}else{link.classList.remove("currentToc");}});});
var h=document.documentElement,b=document.body,st="scrollTop",sh="scrollHeight",progress=document.querySelector(".progress"),scroll;document.addEventListener("scroll",function(){scroll=(h[st]||b[st])/((h[sh]||b[sh])-h.clientHeight)*100;progress.style.setProperty("--scroll",scroll+"%")});
var wxScale=new WxScale({fullPage:document.querySelector("#fullPage"),canvas:document.querySelector("#canvas")});var imgBox=document.querySelectorAll("#md_block img");for(var i=0;i<imgBox.length;i++){imgBox[i].onclick=function(e){wxScale.start(this)}};
</script>
<a id="scrollUp" href="#top" style="position: fixed; z-index: 2147483647; display: block;"></a><div class="footer animated fadeInDown"><div class="site_footer"><div class="mysocials"><div class="my_socials"><a href="https://github.com/AugustuXue"title="github"><i class="iconfont icon-github"></i></a><a href="https://augu5tu.github.io/atom.xml"title="rss"><i class="iconfont icon-rss"></i></a></div></div><div class="copyright"id="copyright">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>Copyright © 2018-2020 <a href="https://augu5tu.github.io" style="margin:0;">Augu5tu-飞光</a>.</div>
<span style="display: inline;margin-right:15px;">👁<strong><span id="busuanzi_value_site_uv"></span></strong></span><span id="busuanzi_container_page_pv" style="display: inline;"><span>📚<strong>5</strong> posts</span></div></div>
<script>
console.log("\n %c \u26a1Theme: Bitcron-pro Author's Blog:https://blog.blinkstar.cn  Writen By Serence  \n\n", "color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;", );
</script>
<script src="https://cdn.jsdelivr.net/npm/instant.page@3.0.0/instantpage.min.js" type="module" defer></script>
<script type="text/javascript" async src="https://augu5tu.github.io/media/js/prism.js"></script>
</body>
</html>